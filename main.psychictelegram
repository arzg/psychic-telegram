fn main(argc int, argv **char) int {
    if argc != 2 {
        printf("provide source filename\n");
        exit(1);
    }

    let filename *char = *(argv + 1);

    let source *char = malloc(262144);
    let f *FILE = fopen(filename, "r");
    let bytes int = 0;
    for {
        let c char = getc(f);
        if c == -1 { break; }
        *(source + bytes) = c;
        bytes += 1;
    }
    fclose(f);
    let p parser = parser_new(source);

    let items []item = make([]item);
    for {
        if parser_ateof(&p) { break; }
        append(item, items, parser_item(&p));
    }

    printf(
        \#include <assert.h>
        \#include <stdbool.h>
        \#include <stdio.h>
        \#include <stdlib.h>
        \#include <string.h>
        \
        \struct __internal__slice {
        \    char *__internal__ptr;
        \    int __internal__len;
        \    int __internal__cap;
        \    int __internal__elemsize;
        \};
        \
        \struct __internal__slice __internal__slice_new(int elemsize) {
        \    struct __internal__slice s;
        \    s.__internal__ptr = malloc(8 * elemsize);
        \    s.__internal__len = 0;
        \    s.__internal__cap = 8;
        \    s.__internal__elemsize = elemsize;
        \    return s;
        \}
        \
        \char *__internal__slice_index(struct __internal__slice s, int i) {
        \    if (i >= s.__internal__len) {
        \        printf("out of bounds slice access (index was %%d but length was %%d)\n", i, s.__internal__len);
        \        abort();
        \    }
        \    return s.__internal__ptr + s.__internal__elemsize * i;
        \}
        \
        \
    );

    let idx int = 0;
    for {
        if idx == len(items) { break; }
        let i item = items[item, idx];
        if i.kind == ITEM_ENUMERATION || i.kind == ITEM_GLOBAL {
            item_codegen(i);
            printf("\n\n");
        }
        idx += 1;
    }

    idx = 0;
    for {
        if idx == len(items) { break; }
        let i item = items[item, idx];
        if i.kind == ITEM_STRUKT {
            item_codegenforwarddeclaration(i);
            printf("\n\n");
        }
        idx += 1;
    }

    idx = 0;
    for {
        if idx == len(items) { break; }
        let i item = items[item, idx];
        if i.kind == ITEM_STRUKT {
            item_codegen(i);
            printf("\n\n");
        }
        idx += 1;
    }

    idx = 0;
    for {
        if idx == len(items) { break; }
        let i item = items[item, idx];
        if i.kind == ITEM_FUNCTION {
            item_codegenforwarddeclaration(i);
            printf("\n\n");
        }
        idx += 1;
    }

    idx = 0;
    for {
        if idx == len(items) { break; }
        let i item = items[item, idx];
        if i.kind == ITEM_FUNCTION {
            item_codegen(i);
            printf("\n\n");
        }
        idx += 1;
    }
}

struct str {
    data *char,
    length int,
}

struct token {
    kind char,
    text str,
}

enum tokenkind {
    TOK_EOF,
    TOK_DOT,
    TOK_ARROW,
    TOK_CHAR,
    TOK_STRING,
    TOK_RAWSTRING,
    TOK_IDENT,
    TOK_NUMBER,
    TOK_LPAREN,
    TOK_RPAREN,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_LSQUARE,
    TOK_RSQUARE,
    TOK_HYPHEN,
    TOK_SEMI,
    TOK_COLON,
    TOK_BANG,
    TOK_STAR,
    TOK_SLASH,
    TOK_AND,
    TOK_PLUS,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_PLUSEQUAL,
    TOK_HYPHENEQUAL,
    TOK_STAREQUAL,
    TOK_SLASHEQUAL,
    TOK_EQUALEQUAL,
    TOK_BANGEQUAL,
    TOK_ANDAND,
    TOK_PIPEPIPE,
    TOK_LTEQUAL,
    TOK_GTEQUAL,
    TOK_LT,
    TOK_GT,
    TOK_LETKW,
    TOK_IFKW,
    TOK_ELSEKW,
    TOK_FNKW,
    TOK_BREAKKW,
    TOK_STRUCTKW,
    TOK_RETURNKW,
    TOK_FORKW,
    TOK_ENUMKW,
    TOK_MAKEKW,
    TOK_APPENDKW,
    TOK_LENKW,
    TOK_ERROR,
}

struct lexer {
    input *char,
    peeked token,
    peekedpresent bool,
}

struct parser {
    lexer lexer,
}

struct type {
    kind char,
    name str,
    pointsto *type,
}

enum typekind {
    TYPE_NAMED,
    TYPE_PTR,
    TYPE_SLICE,
}

struct expr {
    kind char,
    value int,
    name str,
    lhs *expr,
    rhs *expr,
    op int,
    args []expr,
    throughptr bool,
    type type,
}

enum exprkind {
    EXPR_INTLITERAL,
    EXPR_LOCAL,
    EXPR_BIN,
    EXPR_NOT,
    EXPR_NEGATION,
    EXPR_CALL,
    EXPR_ADDROF,
    EXPR_DEREF,
    EXPR_INDEX,
    EXPR_FIELDACCESS,
    EXPR_CHARLITERAL,
    EXPR_STRINGLITERAL,
    EXPR_MAKE,
    EXPR_LEN,
}

enum op {
    OP_ADD,
    OP_SUB,
    OP_MUL,
    OP_DIV,
    OP_ASSIGN,
    OP_ADDASSIGN,
    OP_SUBASSIGN,
    OP_MULASSIGN,
    OP_DIVASSIGN,
    OP_EQUAL,
    OP_NOTEQUAL,
    OP_AND,
    OP_OR,
    OP_LTEQUAL,
    OP_GTEQUAL,
    OP_LT,
    OP_GT,
}

struct block {
    statements []statement,
}

struct statement {
    kind char,
    name str,
    type type,
    initialized bool,
    expr expr,
    block block,
    haselse bool,
    elseblock block,
    condition expr,
}

enum statementkind {
    STATEMENT_EXPR,
    STATEMENT_LET,
    STATEMENT_FOR,
    STATEMENT_IF,
    STATEMENT_RETURN,
    STATEMENT_BREAK,
    STATEMENT_APPEND,
}

struct param {
    name str,
    type type,
}

struct function {
    name str,
    params []param,
    hasreturntype bool,
    returntype type,
    body block,
}

struct field {
    name str,
    type type,
}

struct strukt {
    name str,
    fields []field,
}

struct enumeration {
    name str,
    variants []str,
}

struct global {
    name str,
    val expr,
}

struct item {
    kind char,
    function function,
    strukt strukt,
    enumeration enumeration,
    global global,
}

enum itemkind {
    ITEM_FUNCTION,
    ITEM_STRUKT,
    ITEM_ENUMERATION,
    ITEM_GLOBAL,
}

fn lexer_new(input *char) lexer {
    let l lexer;
    l.input = input;
    l.peekedpresent = false;
    return l;
}

fn lexer_peek(l *lexer) token {
    if l->peekedpresent { return l->peeked; }
    l->peekedpresent = true;
    l->peeked = lexer_realnext(l);
    return l->peeked;
}

fn lexer_next(l *lexer) token {
    if l->peekedpresent {
        l->peekedpresent = false;
        return l->peeked;
    }
    return lexer_realnext(l);
}

fn lexer_realnext(l *lexer) token {
    for {
        if !iswhitespace(*l->input) { break; }
        l->input += 1;
    }

    if *l->input == 0 {
        let t token;
        t.kind = TOK_EOF;
        return t;
    }

    if strncmp("+=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_PLUSEQUAL, 2);
    }
    if strncmp("-=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_HYPHENEQUAL, 2);
    }
    if strncmp("*=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_STAREQUAL, 2);
    }
    if strncmp("/=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_SLASHEQUAL, 2);
    }
    if strncmp("==", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_EQUALEQUAL, 2);
    }
    if strncmp("!=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_BANGEQUAL, 2);
    }
    if strncmp("&&", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_ANDAND, 2);
    }
    if strncmp("||", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_PIPEPIPE, 2);
    }
    if strncmp("<=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_LTEQUAL, 2);
    }
    if strncmp(">=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_GTEQUAL, 2);
    }
    if strncmp("->", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_ARROW, 2);
    }
    if *l->input == '.' { return lexer_advancetoken(l, TOK_DOT, 1); }
    if *l->input == '(' { return lexer_advancetoken(l, TOK_LPAREN, 1); }
    if *l->input == ')' { return lexer_advancetoken(l, TOK_RPAREN, 1); }
    if *l->input == '{' { return lexer_advancetoken(l, TOK_LBRACE, 1); }
    if *l->input == '}' { return lexer_advancetoken(l, TOK_RBRACE, 1); }
    if *l->input == '[' { return lexer_advancetoken(l, TOK_LSQUARE, 1); }
    if *l->input == ']' { return lexer_advancetoken(l, TOK_RSQUARE, 1); }
    if *l->input == '-' { return lexer_advancetoken(l, TOK_HYPHEN, 1); }
    if *l->input == ';' { return lexer_advancetoken(l, TOK_SEMI, 1); }
    if *l->input == ':' { return lexer_advancetoken(l, TOK_COLON, 1); }
    if *l->input == '!' { return lexer_advancetoken(l, TOK_BANG, 1); }
    if *l->input == '*' { return lexer_advancetoken(l, TOK_STAR, 1); }
    if *l->input == '/' { return lexer_advancetoken(l, TOK_SLASH, 1); }
    if *l->input == '&' { return lexer_advancetoken(l, TOK_AND, 1); }
    if *l->input == '+' { return lexer_advancetoken(l, TOK_PLUS, 1); }
    if *l->input == '=' { return lexer_advancetoken(l, TOK_EQUAL, 1); }
    if *l->input == ',' { return lexer_advancetoken(l, TOK_COMMA, 1); }
    if *l->input == '<' { return lexer_advancetoken(l, TOK_LT, 1); }
    if *l->input == '>' { return lexer_advancetoken(l, TOK_GT, 1); }
    if *l->input == '\\' {
        let t token;
        t.kind = TOK_RAWSTRING;
        t.text.data = l->input;
        t.text.length = 0;
        for {
            if *l->input == '\n' { break; }
            l->input += 1;
            t.text.length += 1;
        }
        return t;
    }

    let t token;

    if isasciidigit(*l->input) {
        t.kind = TOK_NUMBER;
        t.text.data = l->input;
        t.text.length = 0;
        for {
            t.text.length += 1;
            l->input += 1;
            if !isasciidigit(*l->input) { break; }
        }
        return t;
    }

    if isidentfirst(*l->input) {
        t.kind = TOK_IDENT;
        t.text.data = l->input;
        t.text.length = 0;
        for {
            t.text.length += 1;
            l->input += 1;
            if !isidentfollow(*l->input) { break; }
        }
        if str_equal(t.text, str_new("let")) { t.kind = TOK_LETKW; }
        if str_equal(t.text, str_new("if")) { t.kind = TOK_IFKW; }
        if str_equal(t.text, str_new("else")) { t.kind = TOK_ELSEKW; }
        if str_equal(t.text, str_new("fn")) { t.kind = TOK_FNKW; }
        if str_equal(t.text, str_new("break")) { t.kind = TOK_BREAKKW; }
        if str_equal(t.text, str_new("struct")) { t.kind = TOK_STRUCTKW; }
        if str_equal(t.text, str_new("return")) { t.kind = TOK_RETURNKW; }
        if str_equal(t.text, str_new("for")) { t.kind = TOK_FORKW; }
        if str_equal(t.text, str_new("enum")) { t.kind = TOK_ENUMKW; }
        if str_equal(t.text, str_new("make")) { t.kind = TOK_MAKEKW; }
        if str_equal(t.text, str_new("append")) { t.kind = TOK_APPENDKW; }
        if str_equal(t.text, str_new("len")) { t.kind = TOK_LENKW; }
        return t;
    }

    if *l->input == 39 {
        t.kind = TOK_CHAR;
        t.text.data = l->input + 1;
        t.text.length = 0;
        for {
            l->input += 1;
            if *l->input == 39 { break; }
            t.text.length += 1;
        }
        l->input += 1;
        return t;
    }

    if *l->input == '"' {
        t.kind = TOK_STRING;
        t.text.data = l->input + 1;
        t.text.length = 0;
        for {
            l->input += 1;
            if *l->input == '"' { break; }
            t.text.length += 1;
            if *l->input == 92 {
                l->input += 1;
                t.text.length += 1;
            }
        }
        l->input += 1;
        return t;
    }

    t.kind = TOK_ERROR;
    t.text.data = l->input;
    t.text.length = 0;
    for {
        if iswhitespace(*l->input) || isidentfirst(*l->input) {
            break;
        }
        t.text.length += 1;
        l->input += 1;
    }

    return t;
}

fn lexer_advancetoken(l *lexer, kind int, bytes int) token {
    let t token;
    t.kind = kind;
    t.text.data = l->input;
    t.text.length = bytes;
    l->input += bytes;
    return t;
}

fn token_print(t token) {
    printf("{ kind: %d:", t.kind);

    if t.kind == TOK_DOT { printf("DOT"); }
    if t.kind == TOK_ARROW { printf("ARROW"); }
    if t.kind == TOK_CHAR { printf("CHAR"); }
    if t.kind == TOK_STRING { printf("STRING"); }
    if t.kind == TOK_IDENT { printf("IDENT"); }
    if t.kind == TOK_NUMBER { printf("NUMBER"); }
    if t.kind == TOK_LPAREN { printf("LPAREN"); }
    if t.kind == TOK_RPAREN { printf("RPAREN"); }
    if t.kind == TOK_LBRACE { printf("LBRACE"); }
    if t.kind == TOK_RBRACE { printf("RBRACE"); }
    if t.kind == TOK_LSQUARE { printf("LSQUARE"); }
    if t.kind == TOK_RSQUARE { printf("RSQUARE"); }
    if t.kind == TOK_HYPHEN { printf("HYPHEN"); }
    if t.kind == TOK_SEMI { printf("SEMI"); }
    if t.kind == TOK_COLON { printf("COLON"); }
    if t.kind == TOK_BANG { printf("BANG"); }
    if t.kind == TOK_STAR { printf("STAR"); }
    if t.kind == TOK_SLASH { printf("SLASH"); }
    if t.kind == TOK_AND { printf("AND"); }
    if t.kind == TOK_PLUS { printf("PLUS"); }
    if t.kind == TOK_EQUAL { printf("EQUAL"); }
    if t.kind == TOK_COMMA { printf("COMMA"); }
    if t.kind == TOK_PLUSEQUAL { printf("PLUSEQUAL"); }
    if t.kind == TOK_HYPHENEQUAL { printf("HYPHENEQUAL"); }
    if t.kind == TOK_STAREQUAL { printf("STAREQUAL"); }
    if t.kind == TOK_SLASHEQUAL { printf("SLASHEQUAL"); }
    if t.kind == TOK_EQUALEQUAL { printf("EQUALEQUAL"); }
    if t.kind == TOK_BANGEQUAL { printf("BANGEQUAL"); }
    if t.kind == TOK_ANDAND { printf("ANDAND"); }
    if t.kind == TOK_PIPEPIPE { printf("PIPEPIPE"); }
    if t.kind == TOK_LTEQUAL { printf("LTEQUAL"); }
    if t.kind == TOK_GTEQUAL { printf("GTEQUAL"); }
    if t.kind == TOK_LT { printf("LT"); }
    if t.kind == TOK_GT { printf("GT"); }
    if t.kind == TOK_LETKW { printf("LETKW"); }
    if t.kind == TOK_IFKW { printf("IFKW"); }
    if t.kind == TOK_ELSEKW { printf("ELSEKW"); }
    if t.kind == TOK_FNKW { printf("FNKW"); }
    if t.kind == TOK_BREAKKW { printf("BREAKKW"); }
    if t.kind == TOK_STRUCTKW { printf("STRUCTKW"); }
    if t.kind == TOK_RETURNKW { printf("RETURNKW"); }
    if t.kind == TOK_FORKW { printf("FORKW"); }
    if t.kind == TOK_ENUMKW { printf("ENUMKW"); }
    if t.kind == TOK_MAKEKW { printf("MAKEKW"); }
    if t.kind == TOK_APPENDKW { printf("APPENDKW"); }
    if t.kind == TOK_LENKW { printf("LENKW"); }
    if t.kind == TOK_ERROR { printf("ERROR"); }
    if t.kind == TOK_EOF {
        printf("EOF }\n");
        return;
    }

    printf(", text: \"");
    str_print(t.text);
    printf("\" }\n");
}


fn parser_new(input *char) parser {
    let p parser;
    p.lexer = lexer_new(input);
    return p;
}

fn parser_item(p *parser) item {
    if lexer_peek(&p->lexer).kind == TOK_FNKW {
        let i item;
        i.kind = ITEM_FUNCTION;
        i.function = parser_function(p);
        return i;
    }

    if lexer_peek(&p->lexer).kind == TOK_STRUCTKW {
        let i item;
        i.kind = ITEM_STRUKT;
        i.strukt = parser_strukt(p);
        return i;
    }

    if lexer_peek(&p->lexer).kind == TOK_ENUMKW {
        let i item;
        i.kind = ITEM_ENUMERATION;
        i.enumeration = parser_enumeration(p);
        return i;
    }

    if lexer_peek(&p->lexer).kind == TOK_LETKW {
        let i item;
        i.kind = ITEM_GLOBAL;
        i.global = parser_global(p);
        return i;
    }

    printf("expected item, got ");
    token_print(lexer_peek(&p->lexer));
    exit(1);
}

fn parser_function(p *parser) function {
    let f function;
    parser_expect(p, TOK_FNKW);
    f.name = parser_expect(p, TOK_IDENT);
    parser_expect(p, TOK_LPAREN);
    f.params = make([]param);
    for {
        if lexer_peek(&p->lexer).kind == TOK_RPAREN { break; }
        let pm param;
        pm.name = parser_expect(p, TOK_IDENT);
        pm.type = parser_type(p);
        if lexer_peek(&p->lexer).kind == TOK_COMMA { lexer_next(&p->lexer); }
        append(param, f.params, pm);
    }
    parser_expect(p, TOK_RPAREN);

    f.hasreturntype = false;
    if lexer_peek(&p->lexer).kind != TOK_LBRACE {
        f.hasreturntype = true;
        f.returntype = parser_type(p);
    }

    f.body = parser_block(p);

    return f;
}

fn parser_strukt(p *parser) strukt {
    let s strukt;
    parser_expect(p, TOK_STRUCTKW);
    s.name = parser_expect(p, TOK_IDENT);
    parser_expect(p, TOK_LBRACE);
    s.fields = make([]field);
    for {
        if lexer_peek(&p->lexer).kind == TOK_RBRACE { break; }
        let f field;
        f.name = parser_expect(p, TOK_IDENT);
        f.type = parser_type(p);
        append(field, s.fields, f);
        if lexer_peek(&p->lexer).kind == TOK_COMMA { lexer_next(&p->lexer); }
    }
    parser_expect(p, TOK_RBRACE);
    return s;
}

fn parser_enumeration(p *parser) enumeration {
    let e enumeration;
    parser_expect(p, TOK_ENUMKW);
    e.name = parser_expect(p, TOK_IDENT);
    parser_expect(p, TOK_LBRACE);
    e.variants = make([]str);
    for {
        if lexer_peek(&p->lexer).kind == TOK_RBRACE { break; }
        append(str, e.variants, parser_expect(p, TOK_IDENT));
        if lexer_peek(&p->lexer).kind == TOK_COMMA { lexer_next(&p->lexer); }
    }
    parser_expect(p, TOK_RBRACE);
    return e;
}

fn parser_global(p *parser) global {
    let g global;
    parser_expect(p, TOK_LETKW);
    g.name = parser_expect(p, TOK_IDENT);
    parser_expect(p, TOK_EQUAL);
    g.val = parser_expr(p);
    parser_expect(p, TOK_SEMI);
    return g;
}

fn parser_statement(p *parser) statement {
    if lexer_peek(&p->lexer).kind == TOK_LETKW { return parser_let(p); }

    if lexer_peek(&p->lexer).kind == TOK_FORKW {
        lexer_next(&p->lexer);
        let s statement;
        s.kind = STATEMENT_FOR;
        s.block = parser_block(p);
        return s;
    }

    if lexer_peek(&p->lexer).kind == TOK_IFKW {
        lexer_next(&p->lexer);
        let s statement;
        s.kind = STATEMENT_IF;
        s.condition = parser_expr(p);
        s.block = parser_block(p);
        s.haselse = false;
        if lexer_peek(&p->lexer).kind == TOK_ELSEKW {
            lexer_next(&p->lexer);
            s.haselse = true;
            s.elseblock = parser_block(p);
        }
        return s;
    }

    if lexer_peek(&p->lexer).kind == TOK_RETURNKW {
        lexer_next(&p->lexer);
        let s statement;
        s.kind = STATEMENT_RETURN;
        if lexer_peek(&p->lexer).kind == TOK_SEMI {
            lexer_next(&p->lexer);
            s.initialized = false;
            return s;
        }
        s.expr = parser_expr(p);
        parser_expect(p, TOK_SEMI);
        s.initialized = true;
        return s;

    }

    if lexer_peek(&p->lexer).kind == TOK_BREAKKW {
        lexer_next(&p->lexer);
        parser_expect(p, TOK_SEMI);
        let s statement;
        s.kind = STATEMENT_BREAK;
        return s;
    }

    if lexer_peek(&p->lexer).kind == TOK_APPENDKW {
        lexer_next(&p->lexer);
        parser_expect(p, TOK_LPAREN);
        let elementtype type = parser_type(p);
        parser_expect(p, TOK_COMMA);
        let slice expr = parser_expr(p);
        parser_expect(p, TOK_COMMA);
        let appendedvalue expr = parser_expr(p);
        parser_expect(p, TOK_RPAREN);
        parser_expect(p, TOK_SEMI);
        let s statement;
        s.kind = STATEMENT_APPEND;
        s.type = elementtype;
        s.condition = slice;
        s.expr = appendedvalue;
        return s;
    }

    let e expr = parser_expr(p);
    parser_expect(p, TOK_SEMI);
    let s statement;
    s.kind = STATEMENT_EXPR;
    s.expr = e;
    return s;
}

fn parser_block(p *parser) block {
    let b block;
    b.statements = make([]statement);
    parser_expect(p, TOK_LBRACE);
    for {
        if lexer_peek(&p->lexer).kind == TOK_RBRACE { break; }
        append(statement, b.statements, parser_statement(p));
    }
    parser_expect(p, TOK_RBRACE);
    return b;
}

fn parser_let(p *parser) statement {
    parser_expect(p, TOK_LETKW);
    let s statement;
    s.kind = STATEMENT_LET;
    s.name = parser_expect(p, TOK_IDENT);
    s.type = parser_type(p);
    if lexer_peek(&p->lexer).kind == TOK_EQUAL {
        lexer_next(&p->lexer);
        s.expr = parser_expr(p);
        s.initialized = true;
    } else {
        s.initialized = false;
    }
    parser_expect(p, TOK_SEMI);
    return s;
}

fn parser_type(p *parser) type {
    let t type;
    if lexer_peek(&p->lexer).kind == TOK_STAR {
        lexer_next(&p->lexer);
        t.kind = TYPE_PTR;
        t.pointsto = malloc(sizeof(type));
        *t.pointsto = parser_type(p);
        return t;
    }
    if lexer_peek(&p->lexer).kind == TOK_LSQUARE {
        lexer_next(&p->lexer);
        parser_expect(p, TOK_RSQUARE);
        t.kind = TYPE_SLICE;
        t.pointsto = malloc(sizeof(type));
        *t.pointsto = parser_type(p);
        return t;
    }
    t.kind = TYPE_NAMED;
    t.name = parser_expect(p, TOK_IDENT);
    return t;
}

fn parser_expr(p *parser) expr {
    return parser_expr_bp(p, 0);
}

fn parser_expr_bp(p *parser, min_bp char) expr {
    let lhs expr = parser_lhs(p);

    for {
        let optoken token = lexer_peek(&p->lexer);
        let op int = -1;

        if optoken.kind == TOK_PLUS { op = OP_ADD; }
        if optoken.kind == TOK_HYPHEN { op = OP_SUB; }
        if optoken.kind == TOK_STAR { op = OP_MUL; }
        if optoken.kind == TOK_SLASH { op = OP_DIV; }
        if optoken.kind == TOK_EQUAL { op = OP_ASSIGN; }
        if optoken.kind == TOK_PLUSEQUAL { op = OP_ADDASSIGN; }
        if optoken.kind == TOK_HYPHENEQUAL { op = OP_SUBASSIGN; }
        if optoken.kind == TOK_STAREQUAL { op = OP_MULASSIGN; }
        if optoken.kind == TOK_SLASHEQUAL { op = OP_DIVASSIGN; }
        if optoken.kind == TOK_EQUALEQUAL { op = OP_EQUAL; }
        if optoken.kind == TOK_BANGEQUAL { op = OP_NOTEQUAL; }
        if optoken.kind == TOK_ANDAND { op = OP_AND; }
        if optoken.kind == TOK_PIPEPIPE { op = OP_OR; }
        if optoken.kind == TOK_LTEQUAL { op = OP_LTEQUAL; }
        if optoken.kind == TOK_GTEQUAL { op = OP_GTEQUAL; }
        if optoken.kind == TOK_LT { op = OP_LT; }
        if optoken.kind == TOK_GT { op = OP_GTEQUAL; }

        if op == -1 { break; }

        let bp bp = op_bp(op);
        if bp.left < min_bp { break; }
        lexer_next(&p->lexer);

        let rhs expr = parser_expr_bp(p, bp.right);
        let new expr;
        new.kind = EXPR_BIN;
        new.lhs = malloc(sizeof(expr));
        new.rhs = malloc(sizeof(expr));
        *new.lhs = lhs;
        *new.rhs = rhs;
        new.op = op;

        lhs = new;
    }

    return lhs;
}

fn parser_lhs(p *parser) expr {
    let token token = lexer_next(&p->lexer);

    if token.kind == TOK_NUMBER {
        let e expr;
        e.kind = EXPR_INTLITERAL;
        e.value = 0;

        let i int = 0;
        for {
            if i == token.text.length { break; }
            let c char = *(token.text.data + i);
            e.value *= 10;
            e.value += c - '0';
            i += 1;
        }

        return parser_postfixexpr(p, e);
    }

    if token.kind == TOK_CHAR {
        let e expr;
        e.kind = EXPR_CHARLITERAL;
        e.name = token.text;
        return parser_postfixexpr(p, e);
    }

    if token.kind == TOK_STRING {
        let e expr;
        e.kind = EXPR_STRINGLITERAL;
        e.name = token.text;
        return parser_postfixexpr(p, e);
    }

    if token.kind == TOK_RAWSTRING {
        let e expr;
        e.kind = EXPR_STRINGLITERAL;
        e.name.data = malloc(4096);
        e.name.length = 0;
        for {
            let i int = 1;
            for {
                if i == token.text.length { break; }
                let c char = *(token.text.data + i);
                if c == '\\' || c == '"' {
                    *(e.name.data + e.name.length) = '\\';
                    e.name.length += 1;
                }
                *(e.name.data + e.name.length) = c;
                e.name.length += 1;
                i += 1;
            }

            if lexer_peek(&p->lexer).kind != TOK_RAWSTRING { break; }

            memcpy(e.name.data + e.name.length, "\\n", 2);
            e.name.length += 2;

            token = lexer_next(&p->lexer);
        }
        return parser_postfixexpr(p, e);
    }

    if token.kind == TOK_IDENT {
        let e expr;

        if lexer_peek(&p->lexer).kind == TOK_LPAREN {
            lexer_next(&p->lexer);
            e.kind = EXPR_CALL;
            e.name = token.text;
            e.args = make([]expr);

            for {
                if lexer_peek(&p->lexer).kind == TOK_RPAREN { break; }
                append(expr, e.args, parser_expr(p));

                if lexer_peek(&p->lexer).kind == TOK_COMMA {
                    lexer_next(&p->lexer);
                }
            }
            lexer_next(&p->lexer);

            return parser_postfixexpr(p, e);
        }

        e.kind = EXPR_LOCAL;
        e.name = token.text;
        return parser_postfixexpr(p, e);
    }

    if token.kind == TOK_MAKEKW {
        let e expr;
        e.kind = EXPR_MAKE;
        parser_expect(p, TOK_LPAREN);
        parser_expect(p, TOK_LSQUARE);
        parser_expect(p, TOK_RSQUARE);
        e.type = parser_type(p);
        parser_expect(p, TOK_RPAREN);
        return e;
    }

    if token.kind == TOK_LENKW {
        let e expr;
        e.kind = EXPR_LEN;
        parser_expect(p, TOK_LPAREN);
        e.lhs = malloc(sizeof(expr));
        *e.lhs = parser_expr(p);
        parser_expect(p, TOK_RPAREN);
        return e;
    }

    if token.kind == TOK_LPAREN {
        let inner expr = parser_expr(p);
        parser_expect(p, TOK_RPAREN);
        return parser_postfixexpr(p, inner);
    }

    if token.kind == TOK_BANG {
        let inner expr = parser_expr_bp(p, 127);
        let e expr;
        e.kind = EXPR_NOT;
        e.lhs = malloc(sizeof(expr));
        *e.lhs = inner;
        return parser_postfixexpr(p, e);
    }

    if token.kind == TOK_HYPHEN {
        let inner expr = parser_expr_bp(p, 127);
        let e expr;
        e.kind = EXPR_NEGATION;
        e.lhs = malloc(sizeof(expr));
        *e.lhs = inner;
        return parser_postfixexpr(p, e);
    }

    if token.kind == TOK_AND {
        let inner expr = parser_expr_bp(p, 127);
        let e expr;
        e.kind = EXPR_ADDROF;
        e.lhs = malloc(sizeof(expr));
        *e.lhs = inner;
        return parser_postfixexpr(p, e);
    }

    if token.kind == TOK_STAR {
        let inner expr = parser_expr_bp(p, 127);
        let e expr;
        e.kind = EXPR_DEREF;
        e.lhs = malloc(sizeof(expr));
        *e.lhs = inner;
        return parser_postfixexpr(p, e);
    }

    printf("unexpected token ");
    token_print(token);
    exit(1);
}

fn parser_postfixexpr(p *parser, e expr) expr {
    for {
        let isdot bool = lexer_peek(&p->lexer).kind == TOK_DOT;
        let isarrow bool = lexer_peek(&p->lexer).kind == TOK_ARROW;
        let isindex bool = lexer_peek(&p->lexer).kind == TOK_LSQUARE;
        if !isdot && !isarrow && !isindex { break; }

        lexer_next(&p->lexer);
        let new expr;

        if isindex {
            new.kind = EXPR_INDEX;
            new.lhs = malloc(sizeof(expr));
            *new.lhs = e;
            new.type = parser_type(p);
            parser_expect(p, TOK_COMMA);
            new.rhs = malloc(sizeof(expr));
            *new.rhs = parser_expr(p);
            parser_expect(p, TOK_RSQUARE);
        } else {
            new.kind = EXPR_FIELDACCESS;
            new.name = parser_expect(p, TOK_IDENT);
            new.lhs = malloc(sizeof(expr));
            new.throughptr = isarrow;
            *new.lhs = e;
        }
        e = new;
    }

    return e;
}

struct bp {
    left char,
    right char,
}

fn op_bp(op char) bp {
    let bp bp;
    if op == OP_ADD || op == OP_SUB {
        bp.left = 11;
        bp.right = 12;
        return bp;
    }
    if op == OP_MUL || op == OP_DIV {
        bp.left = 13;
        bp.right = 14;
        return bp;
    }
    if op == OP_ASSIGN
        || op == OP_ADDASSIGN
        || op == OP_SUBASSIGN
        || op == OP_MULASSIGN
        || op == OP_DIVASSIGN
    {
        bp.left = 1;
        bp.right = 2;
        return bp;
    }
    if op == OP_EQUAL || op == OP_NOTEQUAL {
        bp.left = 7;
        bp.right = 8;
        return bp;
    }
    if op == OP_LTEQUAL || op == OP_GTEQUAL || op == OP_LT || op == OP_GT {
        bp.left = 9;
        bp.right = 10;
        return bp;
    }
    if op == OP_AND {
        bp.left = 5;
        bp.right = 6;
        return bp;
    }
    if op == OP_OR {
        bp.left = 3;
        bp.right = 4;
        return bp;
    }

    printf("bad op\n");
    exit(1);
}

fn parser_expect(p *parser, kind char) str {
    let t token = lexer_next(&p->lexer);
    if t.kind != kind {
        printf("bad token: ");
        token_print(t);
        exit(1);
    }
    return t.text;
}

fn parser_ateof(p *parser) bool {
    return lexer_peek(&p->lexer).kind == TOK_EOF;
}

fn item_codegen(i item) {
    if i.kind == ITEM_FUNCTION { function_codegen(i.function); }
    if i.kind == ITEM_STRUKT { strukt_codegen(i.strukt); }
    if i.kind == ITEM_ENUMERATION { enumeration_codegen(i.enumeration); }
    if i.kind == ITEM_GLOBAL { global_codegen(i.global); }
}

fn item_codegenforwarddeclaration(i item) {
    if i.kind == ITEM_FUNCTION { function_codegenforwarddeclaration(i.function); }
    if i.kind == ITEM_STRUKT { strukt_codegenforwarddeclaration(i.strukt); }
}

fn function_codegen(f function) {
    function_signature(f);
    printf(" ");
    block_codegen(f.body, 0);
}

fn function_codegenforwarddeclaration(f function) {
    function_signature(f);
    printf(";");
}

fn function_signature(f function) {
    if f.hasreturntype { type_codegen(f.returntype); }
    else { printf("void "); }
    str_print(f.name);

    if len(f.params) == 0 {
        printf("(void)");
        return;
    }

    printf("(");
    let i int = 0;
    for {
        if i == len(f.params) { break; }
        if i != 0 { printf(", "); }
        let p param = f.params[param, i];
        type_codegen(p.type);
        str_print(p.name);
        i += 1;
    }
    printf(")");
}

fn strukt_codegen(s strukt) {
    printf("struct ");
    str_print(s.name);
    printf(" {");

    if len(s.fields) == 0 {
        printf("};");
        return;
    }

    let i int = 0;
    for {
        if i == len(s.fields) { break; }
        printf("\n    ");
        let f field = s.fields[field, i];
        type_codegen(f.type);
        str_print(f.name);
        printf(";");
        i += 1;
    }
    printf("\n};");
}

fn strukt_codegenforwarddeclaration(s strukt) {
    printf("typedef struct ");
    str_print(s.name);
    printf(" ");
    str_print(s.name);
    printf(";");
}

fn enumeration_codegen(e enumeration) {
    let i int = 0;
    for {
        if i == len(e.variants) { break; }
        if i != 0 { printf("\n"); }
        let variantname str = e.variants[str, i];
        printf("#define ");
        str_print(variantname);
        printf(" %d", i);
        i += 1;
    }
}

fn global_codegen(g global) {
    printf("#define ");
    str_print(g.name);
    printf(" ");
    expr_codegen(g.val);
}

fn statement_codegen(s statement, indentation int) {
    if s.kind == STATEMENT_EXPR {
        expr_codegen(s.expr);
        printf(";");
    }

    if s.kind == STATEMENT_LET {
        type_codegen(s.type);
        str_print(s.name);
        if s.initialized {
            printf(" = ");
            expr_codegen(s.expr);
        }
        printf(";");
    }

    if s.kind == STATEMENT_FOR {
        printf("while (true) ");
        block_codegen(s.block, indentation);
    }

    if s.kind == STATEMENT_IF {
        printf("if (");
        expr_codegen(s.condition);
        printf(") ");
        block_codegen(s.block, indentation);
        if s.haselse {
            printf(" else ");
            block_codegen(s.elseblock, indentation);
        }
    }

    if s.kind == STATEMENT_RETURN {
        printf("return");
        if s.initialized {
            printf(" ");
            expr_codegen(s.expr);
        }
        printf(";");
    }

    if s.kind == STATEMENT_BREAK {
        printf("break;");
    }

    if s.kind == STATEMENT_APPEND {
        printf("assert(sizeof(");
        type_codegen(s.type);
        printf(") == (");
        expr_codegen(s.condition);
        printf(").__internal__elemsize);");
        newline(indentation);
        printf("if ((");
        expr_codegen(s.condition);
        printf(").__internal__len >= (");
        expr_codegen(s.condition);
        printf(").__internal__cap) {");
        newline(indentation + 1);
        printf("(");
        expr_codegen(s.condition);
        printf(").__internal__cap *= 2;");
        newline(indentation + 1);
        printf("(");
        expr_codegen(s.condition);
        printf(").__internal__ptr = realloc((");
        expr_codegen(s.condition);
        printf(").__internal__ptr, (");
        expr_codegen(s.condition);
        printf(").__internal__cap * (");
        expr_codegen(s.condition);
        printf(").__internal__elemsize);");
        newline(indentation);
        printf("}");
        newline(indentation);
        printf("*((");
        type_codegen(s.type);
        printf("*)(");
        expr_codegen(s.condition);
        printf(").__internal__ptr + (");
        expr_codegen(s.condition);
        printf(").__internal__len) = ");
        expr_codegen(s.expr);
        printf(";");
        newline(indentation);
        printf("(");
        expr_codegen(s.condition);
        printf(").__internal__len += 1;");
    }
}

fn block_codegen(b block, indentation int) {
    if len(b.statements) == 0 {
        printf("{}");
        return;
    }

    printf("{");

    let i int = 0;
    for {
        if i == len(b.statements) { break; }
        newline(indentation + 1);
        statement_codegen(b.statements[statement, i], indentation + 1);
        i += 1;
    }

    newline(indentation);
    printf("}");
}

fn type_codegen(t type) {
    if t.kind == TYPE_NAMED {
        str_print(t.name);
        printf(" ");
    }

    if t.kind == TYPE_PTR {
        type_codegen(*t.pointsto);
        printf("*");
    }

    if t.kind == TYPE_SLICE {
        printf("struct __internal__slice ");
    }
}

fn expr_codegen(e expr) {
    if e.kind == EXPR_INTLITERAL {
        printf("%d", e.value);
    }

    if e.kind == EXPR_LOCAL {
        str_print(e.name);
    }

    if e.kind == EXPR_BIN {
        printf("(");
        expr_codegen(*e.lhs);
        printf(" ");
        if e.op == OP_ADD { printf("+"); }
        if e.op == OP_SUB { printf("-"); }
        if e.op == OP_MUL { printf("*"); }
        if e.op == OP_DIV { printf("/"); }
        if e.op == OP_ASSIGN { printf("="); }
        if e.op == OP_ADDASSIGN { printf("+="); }
        if e.op == OP_SUBASSIGN { printf("-="); }
        if e.op == OP_MULASSIGN { printf("*="); }
        if e.op == OP_DIVASSIGN { printf("/="); }
        if e.op == OP_EQUAL { printf("=="); }
        if e.op == OP_NOTEQUAL { printf("!="); }
        if e.op == OP_AND { printf("&&"); }
        if e.op == OP_OR { printf("||"); }
        if e.op == OP_LTEQUAL { printf("<="); }
        if e.op == OP_GTEQUAL { printf(">="); }
        if e.op == OP_LT { printf("<"); }
        if e.op == OP_GT { printf(">"); }
        printf(" ");
        expr_codegen(*e.rhs);
        printf(")");
    }

    if e.kind == EXPR_NOT {
        printf("!");
        expr_codegen(*e.lhs);
    }

    if e.kind == EXPR_NEGATION {
        printf("-");
        expr_codegen(*e.lhs);
    }

    if e.kind == EXPR_CALL {
        str_print(e.name);
        printf("(");
        let i int = 0;
        for {
            if i == len(e.args) { break; }
            if i != 0 { printf(", "); }
            expr_codegen(e.args[expr, i]);
            i += 1;
        }
        printf(")");
    }

    if e.kind == EXPR_ADDROF {
        printf("&");
        expr_codegen(*e.lhs);
    }

    if e.kind == EXPR_DEREF {
        printf("*");
        expr_codegen(*e.lhs);
    }

    if e.kind == EXPR_INDEX {
        printf("*(");
        type_codegen(e.type);
        printf("*)__internal__slice_index(");
        expr_codegen(*e.lhs);
        printf(", ");
        expr_codegen(*e.rhs);
        printf(")");
    }

    if e.kind == EXPR_FIELDACCESS {
        expr_codegen(*e.lhs);
        if e.throughptr { printf("->"); }
        else { printf("."); }
        str_print(e.name);
    }

    if e.kind == EXPR_CHARLITERAL {
        printf("'");
        str_print(e.name);
        printf("'");
    }

    if e.kind == EXPR_STRINGLITERAL {
        printf("\"");
        str_print(e.name);
        printf("\"");
    }

    if e.kind == EXPR_MAKE {
        printf("__internal__slice_new(sizeof(");
        type_codegen(e.type);
        printf("))");
    }

    if e.kind == EXPR_LEN {
        printf("(");
        expr_codegen(*e.lhs);
        printf(").__internal__len");
    }
}

fn item_print(i item) {
    if i.kind == ITEM_FUNCTION { function_print(i.function); }
    if i.kind == ITEM_STRUKT { strukt_print(i.strukt); }
    if i.kind == ITEM_ENUMERATION { enumeration_print(i.enumeration); }
    if i.kind == ITEM_GLOBAL { global_print(i.global); }
}

fn function_print(f function) {
    printf("fn ");
    str_print(f.name);
    printf("(");
    let i int = 0;
    for {
        if i == len(f.params) { break; }
        if i != 0 { printf(", "); }
        let p param = f.params[param, i];
        str_print(p.name);
        printf(" ");
        type_print(p.type);
        i += 1;
    }
    printf(")");
    if f.hasreturntype {
        printf(" ");
        type_print(f.returntype);
    }
    printf(" ");
    block_print(f.body, 0);
}

fn strukt_print(s strukt) {
    printf("struct ");
    str_print(s.name);
    printf(" {");

    if len(s.fields) == 0 {
        printf("}");
        return;
    }

    let i int = 0;
    for {
        if i == len(s.fields) { break; }
        printf("\n    ");
        let f field = s.fields[field, i];
        str_print(f.name);
        printf(" ");
        type_print(f.type);
        printf(",");
        i += 1;
    }
    printf("\n}");
}

fn enumeration_print(e enumeration) {
    printf("enum ");
    str_print(e.name);
    printf(" {");
    let i int = 0;
    for {
        if i == len(e.variants) { break; }
        printf("\n    ");
        let variantname str = e.variants[str, i];
        str_print(variantname);
        printf(",");
        i += 1;
    }
    printf("\n}");
}

fn global_print(g global) {
    printf("let ");
    str_print(g.name);
    printf(" = ");
    expr_print(g.val);
    printf(";");
}

fn statement_print(s statement, indentation int) {
    if s.kind == STATEMENT_EXPR {
        expr_print(s.expr);
        printf(";");
    }

    if s.kind == STATEMENT_LET {
        printf("let ");
        str_print(s.name);
        printf(" ");
        type_print(s.type);
        if s.initialized {
            printf(" = ");
            expr_print(s.expr);
        }
        printf(";");
    }

    if s.kind == STATEMENT_FOR {
        printf("for ");
        block_print(s.block, indentation);
    }

    if s.kind == STATEMENT_IF {
        printf("if ");
        expr_print(s.condition);
        printf(" ");
        block_print(s.block, indentation);
        if s.haselse {
            printf(" else ");
            block_print(s.elseblock, indentation);
        }
    }

    if s.kind == STATEMENT_RETURN {
        printf("return");
        if s.initialized {
            printf(" ");
            expr_print(s.expr);
        }
        printf(";");
    }

    if s.kind == STATEMENT_BREAK {
        printf("break;");
    }

    if s.kind == STATEMENT_APPEND {
        printf("append(");
        type_print(s.type);
        printf(", ");
        expr_print(s.condition);
        printf(", ");
        expr_print(s.expr);
        printf(");");
    }
}

fn block_print(b block, indentation int) {
    if len(b.statements) {
        printf("{}");
        return;
    }

    printf("{");

    let i int = 0;
    for {
        if i == len(b.statements) { break; }
        newline(indentation + 1);
        statement_print(b.statements[statement, i], indentation + 1);
        i += 1;
    }

    newline(indentation);
    printf("}");
}

fn type_print(t type) {
    if t.kind == TYPE_NAMED {
        str_print(t.name);
        return;
    }

    if t.kind == TYPE_PTR {
        printf("*");
        type_print(*t.pointsto);
    }

    if t.kind == TYPE_SLICE {
        printf("[]");
        type_print(*t.pointsto);
    }
}

fn expr_print(e expr) {
    if e.kind == EXPR_INTLITERAL {
        printf("%d", e.value);
    }

    if e.kind == EXPR_LOCAL {
        str_print(e.name);
    }

    if e.kind == EXPR_BIN {
        printf("(");
        expr_print(*e.lhs);
        printf(" ");
        if e.op == OP_ADD { printf("+"); }
        if e.op == OP_SUB { printf("-"); }
        if e.op == OP_MUL { printf("*"); }
        if e.op == OP_DIV { printf("/"); }
        if e.op == OP_ASSIGN { printf("="); }
        if e.op == OP_ADDASSIGN { printf("+="); }
        if e.op == OP_SUBASSIGN { printf("-="); }
        if e.op == OP_MULASSIGN { printf("*="); }
        if e.op == OP_DIVASSIGN { printf("/="); }
        if e.op == OP_EQUAL { printf("=="); }
        if e.op == OP_NOTEQUAL { printf("!="); }
        if e.op == OP_AND { printf("&&"); }
        if e.op == OP_OR { printf("||"); }
        if e.op == OP_LTEQUAL { printf("<="); }
        if e.op == OP_GTEQUAL { printf(">="); }
        if e.op == OP_LT { printf("<"); }
        if e.op == OP_GT { printf(">"); }
        printf(" ");
        expr_print(*e.rhs);
        printf(")");
    }

    if e.kind == EXPR_NOT {
        printf("!(");
        expr_print(*e.lhs);
        printf(")");
    }

    if e.kind == EXPR_NEGATION {
        printf("-(");
        expr_print(*e.lhs);
        printf(")");
    }

    if e.kind == EXPR_CALL {
        str_print(e.name);
        printf("(");
        let i int = 0;
        for {
            if i == len(e.args) { break; }
            if i != 0 { printf(", "); }
            expr_print(e.args[expr, i]);
            i += 1;
        }
        printf(")");
    }

    if e.kind == EXPR_ADDROF {
        printf("&(");
        expr_print(*e.lhs);
        printf(")");
    }

    if e.kind == EXPR_DEREF {
        printf("*(");
        expr_print(*e.lhs);
        printf(")");
    }

    if e.kind == EXPR_INDEX {
        printf("(");
        expr_codegen(*e.lhs);
        printf(")[");
        expr_codegen(*e.rhs);
        printf("]");
    }

    if e.kind == EXPR_FIELDACCESS {
        printf("(");
        expr_print(*e.lhs);
        printf(")");
        if e.throughptr { printf("->"); }
        else { printf("."); }
        str_print(e.name);
    }

    if e.kind == EXPR_CHARLITERAL {
        printf("'");
        str_print(e.name);
        printf("'");
    }

    if e.kind == EXPR_STRINGLITERAL {
        printf("\"");
        str_print(e.name);
        printf("\"");
    }

    if e.kind == EXPR_MAKE {
        printf("make([]");
        type_print(e.type);
        printf(")");
    }

    if e.kind == EXPR_LEN {
        printf("len(");
        expr_print(*e.lhs);
        printf(")");
    }
}

fn newline(indentation int) {
    printf("\n");
    let i int = 0;
    for {
        if i == indentation { break; }
        printf("    ");
        i += 1;
    }
}

fn str_new(cs *char) str {
    let s str;

    s.length = 0;
    for {
        if *(cs + s.length) == 0 { break; }
        s.length += 1;
    }

    s.data = cs;
    return s;
}

fn str_equal(l str, r str) bool {
    if l.length != r.length { return false; }
    let i int = 0;
    for {
        if i == l.length { break; }
        if *(l.data + i) != *(r.data + i) { return false; }
        i += 1;
    }
    return true;
}

fn str_print(s str) {
    let i int = 0;
    for {
        if i == s.length { break; }
        printf("%c", *(s.data + i));
        i += 1;
    }
}

fn iswhitespace(c char) bool {
    return c == ' ' || c == '\n';
}

fn isasciidigit(c char) bool {
    return c >= '0' && c <= '9';
}

fn isasciialphabetic(c char) bool {
    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
}

fn isidentfirst(c char) bool {
    return isasciialphabetic(c) || c == '_';
}

fn isidentfollow(c char) bool {
    return isidentfirst(c) || isasciidigit(c);
}
