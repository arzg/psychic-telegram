fn main() int {
    let source: *char = malloc(65536);
    let f: *FILE = fopen("main.psychictelegram", "r");
    let bytes: int = 0;
    for {
        let c: char = getc(f);
        if c == -1 { break; }
        *(source + bytes) = c;
        bytes += 1;
    }
    fclose(f);
    let p: parser = parser_new(source);

    let items: *item = malloc(4096 * sizeof(item));
    let itemslen: int = 0;
    for {
        if parser_ateof(&p) { break; }
        *(items + itemslen) = parser_item(&p);
        itemslen += 1;
    }

    printf("#include <stdbool.h>\n");
    printf("#include <stdio.h>\n");
    printf("#include <stdlib.h>\n");
    printf("#include <string.h>\n");
    printf("\n");

    let i: int = 0;
    for {
        if i == itemslen { break; }
        let item: item = *(items + i);
        if item.kind == ITEM_GLOBAL {
            item_codegen(item);
            printf("\n\n");
        }
        i += 1;
    }

    i = 0;
    for {
        if i == itemslen { break; }
        let item: item = *(items + i);
        if item.kind == ITEM_STRUKT {
            item_codegenforwarddeclaration(item);
            printf("\n\n");
        }
        i += 1;
    }

    i = 0;
    for {
        if i == itemslen { break; }
        let item: item = *(items + i);
        if item.kind == ITEM_STRUKT {
            item_codegen(item);
            printf("\n\n");
        }
        i += 1;
    }

    i = 0;
    for {
        if i == itemslen { break; }
        let item: item = *(items + i);
        if item.kind == ITEM_FUNCTION {
            item_codegenforwarddeclaration(item);
            printf("\n\n");
        }
        i += 1;
    }

    i = 0;
    for {
        if i == itemslen { break; }
        let item: item = *(items + i);
        if item.kind == ITEM_FUNCTION {
            item_codegen(item);
            printf("\n\n");
        }
        i += 1;
    }
}

struct str {
    data: *char,
    len: int,
}

struct token {
    kind: char,
    text: str,
}

let TOK_EOF = 0;
let TOK_DOT = 1;
let TOK_ARROW = 2;
let TOK_CHAR = 3;
let TOK_STRING = 4;
let TOK_IDENT = 5;
let TOK_NUMBER = 6;
let TOK_LPAREN = 7;
let TOK_RPAREN = 8;
let TOK_LBRACE = 9;
let TOK_RBRACE = 10;
let TOK_HYPHEN = 11;
let TOK_SEMI = 12;
let TOK_COLON = 13;
let TOK_BANG = 14;
let TOK_STAR = 15;
let TOK_SLASH = 16;
let TOK_AND = 17;
let TOK_PLUS = 18;
let TOK_EQUAL = 19;
let TOK_COMMA = 20;
let TOK_PLUSEQUAL = 21;
let TOK_HYPHENEQUAL = 22;
let TOK_STAREQUAL = 23;
let TOK_SLASHEQUAL = 24;
let TOK_EQUALEQUAL = 25;
let TOK_BANGEQUAL = 26;
let TOK_ANDAND = 27;
let TOK_PIPEPIPE = 28;
let TOK_LTEQUAL = 29;
let TOK_GTEQUAL = 30;
let TOK_LT = 31;
let TOK_GT = 32;
let TOK_LETKW = 33;
let TOK_IFKW = 34;
let TOK_ELSEKW = 35;
let TOK_FNKW = 36;
let TOK_BREAKKW = 37;
let TOK_STRUCTKW = 38;
let TOK_RETURNKW = 39;
let TOK_FORKW = 40;
let TOK_ERROR = 41;

struct lexer {
    input: *char,
    peeked: token,
    peekedpresent: bool,
}

struct parser {
    lexer: lexer,
}

struct expr {
    kind: char,
    value: int,
    name: str,
    lhs: *expr,
    rhs: *expr,
    op: int,
    args: *expr,
    numargs: int,
    throughptr: bool,
}

let EXPR_INTLITERAL = 1;
let EXPR_LOCAL = 2;
let EXPR_BIN = 3;
let EXPR_NOT = 4;
let EXPR_NEGATION = 5;
let EXPR_CALL = 6;
let EXPR_ADDROF = 7;
let EXPR_DEREF = 8;
let EXPR_FIELDACCESS = 9;
let EXPR_CHARLITERAL = 10;
let EXPR_STRINGLITERAL = 11;

let OP_ADD = 1;
let OP_SUB = 2;
let OP_MUL = 3;
let OP_DIV = 4;
let OP_ASSIGN = 5;
let OP_ADDASSIGN = 6;
let OP_SUBASSIGN = 7;
let OP_MULASSIGN = 8;
let OP_DIVASSIGN = 9;
let OP_EQUAL = 10;
let OP_NOTEQUAL = 11;
let OP_AND = 12;
let OP_OR = 13;
let OP_LTEQUAL = 14;
let OP_GTEQUAL = 15;
let OP_LT = 16;
let OP_GT = 17;

struct type {
    kind: char,
    name: str,
    pointsto: *type,
}

let TYPE_NAMED = 1;
let TYPE_PTR = 2;

struct block {
    statements: *statement,
    len: int,
}

struct statement {
    kind: char,
    name: str,
    type: type,
    initialized: bool,
    expr: expr,
    block: block,
    haselse: bool,
    elseblock: block,
    condition: expr,
}

let STATEMENT_EXPR = 1;
let STATEMENT_LET = 2;
let STATEMENT_FOR = 3;
let STATEMENT_IF = 4;
let STATEMENT_RETURN = 5;
let STATEMENT_BREAK = 6;

struct param {
    name: str,
    type: type,
}

struct function {
    name: str,
    params: *param,
    paramslen: int,
    hasreturntype: bool,
    returntype: type,
    body: block,
}

struct field {
    name: str,
    type: type,
}

struct strukt {
    name: str,
    fields: *field,
    fieldslen: int,
}

struct global {
    name: str,
    val: expr,
}

struct item {
    kind: char,
    function: function,
    strukt: strukt,
    global: global,
}

let ITEM_FUNCTION = 1;
let ITEM_STRUKT = 2;
let ITEM_GLOBAL = 3;

fn lexer_new(input: *char) lexer {
    let l: lexer;
    l.input = input;
    l.peekedpresent = false;
    return l;
}

fn lexer_peek(l: *lexer) token {
    if l->peekedpresent { return l->peeked; }
    l->peekedpresent = true;
    l->peeked = lexer_realnext(l);
    return l->peeked;
}

fn lexer_next(l: *lexer) token {
    if l->peekedpresent {
        l->peekedpresent = false;
        return l->peeked;
    }
    return lexer_realnext(l);
}

fn lexer_realnext(l: *lexer) token {
    for {
        if !iswhitespace(*l->input) { break; }
        l->input += 1;
    }

    if *l->input == 0 {
        let t: token;
        t.kind = TOK_EOF;
        return t;
    }

    if strncmp("+=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_PLUSEQUAL, 2);
    }
    if strncmp("-=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_HYPHENEQUAL, 2);
    }
    if strncmp("*=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_STAREQUAL, 2);
    }
    if strncmp("/=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_SLASHEQUAL, 2);
    }
    if strncmp("==", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_EQUALEQUAL, 2);
    }
    if strncmp("!=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_BANGEQUAL, 2);
    }
    if strncmp("&&", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_ANDAND, 2);
    }
    if strncmp("||", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_PIPEPIPE, 2);
    }
    if strncmp("<=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_LTEQUAL, 2);
    }
    if strncmp(">=", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_GTEQUAL, 2);
    }
    if strncmp("->", l->input, 2) == 0 {
        return lexer_advancetoken(l, TOK_ARROW, 2);
    }
    if *l->input == '.' { return lexer_advancetoken(l, TOK_DOT, 1); }
    if *l->input == '(' { return lexer_advancetoken(l, TOK_LPAREN, 1); }
    if *l->input == ')' { return lexer_advancetoken(l, TOK_RPAREN, 1); }
    if *l->input == '{' { return lexer_advancetoken(l, TOK_LBRACE, 1); }
    if *l->input == '}' { return lexer_advancetoken(l, TOK_RBRACE, 1); }
    if *l->input == '-' { return lexer_advancetoken(l, TOK_HYPHEN, 1); }
    if *l->input == ';' { return lexer_advancetoken(l, TOK_SEMI, 1); }
    if *l->input == ':' { return lexer_advancetoken(l, TOK_COLON, 1); }
    if *l->input == '!' { return lexer_advancetoken(l, TOK_BANG, 1); }
    if *l->input == '*' { return lexer_advancetoken(l, TOK_STAR, 1); }
    if *l->input == '/' { return lexer_advancetoken(l, TOK_SLASH, 1); }
    if *l->input == '&' { return lexer_advancetoken(l, TOK_AND, 1); }
    if *l->input == '+' { return lexer_advancetoken(l, TOK_PLUS, 1); }
    if *l->input == '=' { return lexer_advancetoken(l, TOK_EQUAL, 1); }
    if *l->input == ',' { return lexer_advancetoken(l, TOK_COMMA, 1); }
    if *l->input == '<' { return lexer_advancetoken(l, TOK_LT, 1); }
    if *l->input == '>' { return lexer_advancetoken(l, TOK_GT, 1); }

    let t: token;

    if isasciidigit(*l->input) {
        t.kind = TOK_NUMBER;
        t.text.data = l->input;
        t.text.len = 0;
        for {
            t.text.len += 1;
            l->input += 1;
            if !isasciidigit(*l->input) { break; }
        }
        return t;
    }

    if isidentfirst(*l->input) {
        t.kind = TOK_IDENT;
        t.text.data = l->input;
        t.text.len = 0;
        for {
            t.text.len += 1;
            l->input += 1;
            if !isidentfollow(*l->input) { break; }
        }
        if str_equal(t.text, str_new("let")) { t.kind = TOK_LETKW; }
        if str_equal(t.text, str_new("if")) { t.kind = TOK_IFKW; }
        if str_equal(t.text, str_new("else")) { t.kind = TOK_ELSEKW; }
        if str_equal(t.text, str_new("fn")) { t.kind = TOK_FNKW; }
        if str_equal(t.text, str_new("break")) { t.kind = TOK_BREAKKW; }
        if str_equal(t.text, str_new("struct")) { t.kind = TOK_STRUCTKW; }
        if str_equal(t.text, str_new("return")) { t.kind = TOK_RETURNKW; }
        if str_equal(t.text, str_new("for")) { t.kind = TOK_FORKW; }
        return t;
    }

    if *l->input == 39 {
        t.kind = TOK_CHAR;
        t.text.data = l->input + 1;
        t.text.len = 0;
        for {
            l->input += 1;
            if *l->input == 39 { break; }
            t.text.len += 1;
        }
        l->input += 1;
        return t;
    }

    if *l->input == '"' {
        t.kind = TOK_STRING;
        t.text.data = l->input + 1;
        t.text.len = 0;
        for {
            l->input += 1;
            if *l->input == '"' { break; }
            t.text.len += 1;
            if *l->input == 92 {
                l->input += 1;
                t.text.len += 1;
            }
        }
        l->input += 1;
        return t;
    }

    t.kind = TOK_ERROR;
    t.text.data = l->input;
    t.text.len = 0;
    for {
        if iswhitespace(*l->input) || isidentfirst(*l->input) {
            break;
        }
        t.text.len += 1;
        l->input += 1;
    }

    return t;
}

fn lexer_advancetoken(l: *lexer, kind: int, bytes: int) token {
    let t: token;
    t.kind = kind;
    t.text.data = l->input;
    t.text.len = bytes;
    l->input += bytes;
    return t;
}

fn token_print(t: token) {
    printf("{ kind: %d:", t.kind);

    if t.kind == TOK_DOT { printf("DOT"); }
    if t.kind == TOK_ARROW { printf("ARROW"); }
    if t.kind == TOK_CHAR { printf("CHAR"); }
    if t.kind == TOK_STRING { printf("STRING"); }
    if t.kind == TOK_IDENT { printf("IDENT"); }
    if t.kind == TOK_NUMBER { printf("NUMBER"); }
    if t.kind == TOK_LPAREN { printf("LPAREN"); }
    if t.kind == TOK_RPAREN { printf("RPAREN"); }
    if t.kind == TOK_LBRACE { printf("LBRACE"); }
    if t.kind == TOK_RBRACE { printf("RBRACE"); }
    if t.kind == TOK_HYPHEN { printf("HYPHEN"); }
    if t.kind == TOK_SEMI { printf("SEMI"); }
    if t.kind == TOK_COLON { printf("COLON"); }
    if t.kind == TOK_BANG { printf("BANG"); }
    if t.kind == TOK_STAR { printf("STAR"); }
    if t.kind == TOK_SLASH { printf("SLASH"); }
    if t.kind == TOK_AND { printf("AND"); }
    if t.kind == TOK_PLUS { printf("PLUS"); }
    if t.kind == TOK_EQUAL { printf("EQUAL"); }
    if t.kind == TOK_COMMA { printf("COMMA"); }
    if t.kind == TOK_PLUSEQUAL { printf("PLUSEQUAL"); }
    if t.kind == TOK_HYPHENEQUAL { printf("HYPHENEQUAL"); }
    if t.kind == TOK_STAREQUAL { printf("STAREQUAL"); }
    if t.kind == TOK_SLASHEQUAL { printf("SLASHEQUAL"); }
    if t.kind == TOK_EQUALEQUAL { printf("EQUALEQUAL"); }
    if t.kind == TOK_BANGEQUAL { printf("BANGEQUAL"); }
    if t.kind == TOK_ANDAND { printf("ANDAND"); }
    if t.kind == TOK_PIPEPIPE { printf("PIPEPIPE"); }
    if t.kind == TOK_LTEQUAL { printf("LTEQUAL"); }
    if t.kind == TOK_GTEQUAL { printf("GTEQUAL"); }
    if t.kind == TOK_LT { printf("LT"); }
    if t.kind == TOK_GT { printf("GT"); }
    if t.kind == TOK_LETKW { printf("LETKW"); }
    if t.kind == TOK_IFKW { printf("IFKW"); }
    if t.kind == TOK_ELSEKW { printf("ELSEKW"); }
    if t.kind == TOK_FNKW { printf("FNKW"); }
    if t.kind == TOK_BREAKKW { printf("BREAKKW"); }
    if t.kind == TOK_STRUCTKW { printf("STRUCTKW"); }
    if t.kind == TOK_RETURNKW { printf("RETURNKW"); }
    if t.kind == TOK_FORKW { printf("FORKW"); }
    if t.kind == TOK_ERROR { printf("ERROR"); }
    if t.kind == TOK_EOF {
        printf("EOF }\n");
        return;
    }

    printf(", text: \"");
    str_print(t.text);
    printf("\" }\n");
}


fn parser_new(input: *char) parser {
    let p: parser;
    p.lexer = lexer_new(input);
    return p;
}

fn parser_item(p: *parser) item {
    if lexer_peek(&p->lexer).kind == TOK_FNKW {
        let i: item;
        i.kind = ITEM_FUNCTION;
        i.function = parser_function(p);
        return i;
    }

    if lexer_peek(&p->lexer).kind == TOK_STRUCTKW {
        let i: item;
        i.kind = ITEM_STRUKT;
        i.strukt = parser_strukt(p);
        return i;
    }

    if lexer_peek(&p->lexer).kind == TOK_LETKW {
        let i: item;
        i.kind = ITEM_GLOBAL;
        i.global = parser_global(p);
        return i;
    }

    printf("expected item, got ");
    token_print(lexer_peek(&p->lexer));
    exit(1);
}

fn parser_function(p: *parser) function {
    let f: function;
    parser_expect(p, TOK_FNKW);
    f.name = parser_expect(p, TOK_IDENT);
    parser_expect(p, TOK_LPAREN);
    f.params = malloc(8 * sizeof(param));
    f.paramslen = 0;
    for {
        if lexer_peek(&p->lexer).kind == TOK_RPAREN { break; }
        let param: param;
        param.name = parser_expect(p, TOK_IDENT);
        parser_expect(p, TOK_COLON);
        param.type = parser_type(p);
        if lexer_peek(&p->lexer).kind == TOK_COMMA { lexer_next(&p->lexer); }
        *(f.params + f.paramslen) = param;
        f.paramslen += 1;
    }
    parser_expect(p, TOK_RPAREN);

    f.hasreturntype = false;
    if lexer_peek(&p->lexer).kind != TOK_LBRACE {
        f.hasreturntype = true;
        f.returntype = parser_type(p);
    }

    f.body = parser_block(p);

    return f;
}

fn parser_strukt(p: *parser) strukt {
    let s: strukt;
    parser_expect(p, TOK_STRUCTKW);
    s.name = parser_expect(p, TOK_IDENT);
    parser_expect(p, TOK_LBRACE);
    s.fields = malloc(64 * sizeof(field));
    s.fieldslen = 0;
    for {
        if lexer_peek(&p->lexer).kind == TOK_RBRACE { break; }
        let f: field;
        f.name = parser_expect(p, TOK_IDENT);
        parser_expect(p, TOK_COLON);
        f.type = parser_type(p);
        *(s.fields + s.fieldslen) = f;
        if lexer_peek(&p->lexer).kind == TOK_COMMA { lexer_next(&p->lexer); }
        s.fieldslen += 1;
    }
    parser_expect(p, TOK_RBRACE);
    return s;
}

fn parser_global(p: *parser) global {
    let g: global;
    parser_expect(p, TOK_LETKW);
    g.name = parser_expect(p, TOK_IDENT);
    parser_expect(p, TOK_EQUAL);
    g.val = parser_expr(p);
    parser_expect(p, TOK_SEMI);
    return g;
}

fn parser_statement(p: *parser) statement {
    if lexer_peek(&p->lexer).kind == TOK_LETKW { return parser_let(p); }

    if lexer_peek(&p->lexer).kind == TOK_FORKW {
        lexer_next(&p->lexer);
        let s: statement;
        s.kind = STATEMENT_FOR;
        s.block = parser_block(p);
        return s;
    }

    if lexer_peek(&p->lexer).kind == TOK_IFKW {
        lexer_next(&p->lexer);
        let s: statement;
        s.kind = STATEMENT_IF;
        s.condition = parser_expr(p);
        s.block = parser_block(p);
        s.haselse = false;
        if lexer_peek(&p->lexer).kind == TOK_ELSEKW {
            lexer_next(&p->lexer);
            s.haselse = true;
            s.elseblock = parser_block(p);
        }
        return s;
    }

    if lexer_peek(&p->lexer).kind == TOK_RETURNKW {
        lexer_next(&p->lexer);
        let s: statement;
        s.kind = STATEMENT_RETURN;
        if lexer_peek(&p->lexer).kind == TOK_SEMI {
            lexer_next(&p->lexer);
            s.initialized = false;
            return s;
        }
        s.expr = parser_expr(p);
        parser_expect(p, TOK_SEMI);
        s.initialized = true;
        return s;

    }

    if lexer_peek(&p->lexer).kind == TOK_BREAKKW {
        lexer_next(&p->lexer);
        parser_expect(p, TOK_SEMI);
        let s: statement;
        s.kind = STATEMENT_BREAK;
        return s;
    }

    let e: expr = parser_expr(p);
    parser_expect(p, TOK_SEMI);
    let s: statement;
    s.kind = STATEMENT_EXPR;
    s.expr = e;
    return s;
}

fn parser_block(p: *parser) block {
    let b: block;
    b.statements = malloc(64 * sizeof(statement));
    b.len = 0;
    parser_expect(p, TOK_LBRACE);
    for {
        if lexer_peek(&p->lexer).kind == TOK_RBRACE { break; }
        *(b.statements + b.len) = parser_statement(p);
        b.len += 1;
    }
    parser_expect(p, TOK_RBRACE);
    return b;
}

fn parser_let(p: *parser) statement {
    parser_expect(p, TOK_LETKW);
    let s: statement;
    s.kind = STATEMENT_LET;
    s.name = parser_expect(p, TOK_IDENT);
    parser_expect(p, TOK_COLON);
    s.type = parser_type(p);
    if lexer_peek(&p->lexer).kind == TOK_EQUAL {
        lexer_next(&p->lexer);
        s.expr = parser_expr(p);
        s.initialized = true;
    } else {
        s.initialized = false;
    }
    parser_expect(p, TOK_SEMI);
    return s;
}

fn parser_type(p: *parser) type {
    let t: type;
    if lexer_peek(&p->lexer).kind == TOK_STAR {
        lexer_next(&p->lexer);
        t.kind = TYPE_PTR;
        t.pointsto = malloc(sizeof(type));
        *t.pointsto = parser_type(p);
        return t;
    }
    t.kind = TYPE_NAMED;
    t.name = parser_expect(p, TOK_IDENT);
    return t;
}

fn parser_expr(p: *parser) expr {
    return parser_expr_bp(p, 0);
}

fn parser_expr_bp(p: *parser, min_bp: char) expr {
    let lhs: expr = parser_lhs(p);

    for {
        let optoken: token = lexer_peek(&p->lexer);
        let op: int = -1;

        if optoken.kind == TOK_PLUS { op = OP_ADD; }
        if optoken.kind == TOK_HYPHEN { op = OP_SUB; }
        if optoken.kind == TOK_STAR { op = OP_MUL; }
        if optoken.kind == TOK_SLASH { op = OP_DIV; }
        if optoken.kind == TOK_EQUAL { op = OP_ASSIGN; }
        if optoken.kind == TOK_PLUSEQUAL { op = OP_ADDASSIGN; }
        if optoken.kind == TOK_HYPHENEQUAL { op = OP_SUBASSIGN; }
        if optoken.kind == TOK_STAREQUAL { op = OP_MULASSIGN; }
        if optoken.kind == TOK_SLASHEQUAL { op = OP_DIVASSIGN; }
        if optoken.kind == TOK_EQUALEQUAL { op = OP_EQUAL; }
        if optoken.kind == TOK_BANGEQUAL { op = OP_NOTEQUAL; }
        if optoken.kind == TOK_ANDAND { op = OP_AND; }
        if optoken.kind == TOK_PIPEPIPE { op = OP_OR; }
        if optoken.kind == TOK_LTEQUAL { op = OP_LTEQUAL; }
        if optoken.kind == TOK_GTEQUAL { op = OP_GTEQUAL; }
        if optoken.kind == TOK_LT { op = OP_LT; }
        if optoken.kind == TOK_GT { op = OP_GTEQUAL; }

        if op == -1 { break; }

        let bp: bp = op_bp(op);
        if bp.left < min_bp { break; }
        lexer_next(&p->lexer);

        let rhs: expr = parser_expr_bp(p, bp.right);
        let new: expr;
        new.kind = EXPR_BIN;
        new.lhs = malloc(sizeof(expr));
        new.rhs = malloc(sizeof(expr));
        *new.lhs = lhs;
        *new.rhs = rhs;
        new.op = op;

        lhs = new;
    }

    return lhs;
}

fn parser_lhs(p: *parser) expr {
    let token: token = lexer_next(&p->lexer);

    if token.kind == TOK_NUMBER {
        let e: expr;
        e.kind = EXPR_INTLITERAL;
        e.value = 0;

        let i: int = 0;
        for {
            if i == token.text.len { break; }
            let c: char = *(token.text.data + i);
            e.value *= 10;
            e.value += c - '0';
            i += 1;
        }

        return parser_fieldaccess(p, e);
    }

    if token.kind == TOK_CHAR {
        let e: expr;
        e.kind = EXPR_CHARLITERAL;
        e.name = token.text;
        return parser_fieldaccess(p, e);
    }

    if token.kind == TOK_STRING {
        let e: expr;
        e.kind = EXPR_STRINGLITERAL;
        e.name = token.text;
        return parser_fieldaccess(p, e);
    }

    if token.kind == TOK_IDENT {
        let e: expr;

        if lexer_peek(&p->lexer).kind == TOK_LPAREN {
            lexer_next(&p->lexer);
            e.kind = EXPR_CALL;
            e.name = token.text;
            e.numargs = 0;
            e.args = malloc(8 * sizeof(expr));

            for {
                if lexer_peek(&p->lexer).kind == TOK_RPAREN { break; }
                let arg: expr = parser_expr(p);

                *(e.args + e.numargs) = arg;
                e.numargs += 1;

                if lexer_peek(&p->lexer).kind == TOK_COMMA {
                    lexer_next(&p->lexer);
                }
            }
            lexer_next(&p->lexer);

            return parser_fieldaccess(p, e);
        }

        e.kind = EXPR_LOCAL;
        e.name = token.text;
        return parser_fieldaccess(p, e);
    }

    if token.kind == TOK_LPAREN {
        let inner: expr = parser_expr(p);
        parser_expect(p, TOK_RPAREN);
        return parser_fieldaccess(p, inner);
    }

    if token.kind == TOK_BANG {
        let inner: expr = parser_expr_bp(p, 127);
        let e: expr;
        e.kind = EXPR_NOT;
        e.lhs = malloc(sizeof(expr));
        *e.lhs = inner;
        return parser_fieldaccess(p, e);
    }

    if token.kind == TOK_HYPHEN {
        let inner: expr = parser_expr_bp(p, 127);
        let e: expr;
        e.kind = EXPR_NEGATION;
        e.lhs = malloc(sizeof(expr));
        *e.lhs = inner;
        return parser_fieldaccess(p, e);
    }

    if token.kind == TOK_AND {
        let inner: expr = parser_expr_bp(p, 127);
        let e: expr;
        e.kind = EXPR_ADDROF;
        e.lhs = malloc(sizeof(expr));
        *e.lhs = inner;
        return parser_fieldaccess(p, e);
    }

    if token.kind == TOK_STAR {
        let inner: expr = parser_expr_bp(p, 127);
        let e: expr;
        e.kind = EXPR_DEREF;
        e.lhs = malloc(sizeof(expr));
        *e.lhs = inner;
        return parser_fieldaccess(p, e);
    }

    printf("unexpected token ");
    token_print(token);
    exit(1);
}

fn parser_fieldaccess(p: *parser, e: expr) expr {
    for {
        let isdot: bool = lexer_peek(&p->lexer).kind == TOK_DOT;
        let isarrow: bool = lexer_peek(&p->lexer).kind == TOK_ARROW;
        if !isdot && !isarrow { break; }

        lexer_next(&p->lexer);
        let new: expr;
        new.kind = EXPR_FIELDACCESS;
        new.name = parser_expect(p, TOK_IDENT);
        new.lhs = malloc(sizeof(expr));
        new.throughptr = isarrow;
        *new.lhs = e;
        e = new;
    }

    return e;
}

struct bp {
    left: char,
    right: char,
}

fn op_bp(op: char) bp {
    let bp: bp;
    if op == OP_ADD || op == OP_SUB {
        bp.left = 11;
        bp.right = 12;
        return bp;
    }
    if op == OP_MUL || op == OP_DIV {
        bp.left = 13;
        bp.right = 14;
        return bp;
    }
    if op == OP_ASSIGN
        || op == OP_ADDASSIGN
        || op == OP_SUBASSIGN
        || op == OP_MULASSIGN
        || op == OP_DIVASSIGN
    {
        bp.left = 1;
        bp.right = 2;
        return bp;
    }
    if op == OP_EQUAL || op == OP_NOTEQUAL {
        bp.left = 7;
        bp.right = 8;
        return bp;
    }
    if op == OP_LTEQUAL || op == OP_GTEQUAL || op == OP_LT || op == OP_GT {
        bp.left = 9;
        bp.right = 10;
        return bp;
    }
    if op == OP_AND {
        bp.left = 5;
        bp.right = 6;
        return bp;
    }
    if op == OP_OR {
        bp.left = 3;
        bp.right = 4;
        return bp;
    }

    printf("bad op\n");
    exit(1);
}

fn parser_expect(p: *parser, kind: char) str {
    let t: token = lexer_next(&p->lexer);
    if t.kind != kind {
        printf("bad token: ");
        token_print(t);
        exit(1);
    }
    return t.text;
}

fn parser_ateof(p: *parser) bool {
    return lexer_peek(&p->lexer).kind == TOK_EOF;
}

fn item_codegen(i: item) {
    if i.kind == ITEM_FUNCTION { function_codegen(i.function); }
    if i.kind == ITEM_STRUKT { strukt_codegen(i.strukt); }
    if i.kind == ITEM_GLOBAL { global_codegen(i.global); }
}

fn item_codegenforwarddeclaration(i: item) {
    if i.kind == ITEM_FUNCTION { function_codegenforwarddeclaration(i.function); }
    if i.kind == ITEM_STRUKT { strukt_codegenforwarddeclaration(i.strukt); }
}

fn function_codegen(f: function) {
    function_signature(f);
    printf(" ");
    block_codegen(f.body, 0);
}

fn function_codegenforwarddeclaration(f: function) {
    function_signature(f);
    printf(";");
}

fn function_signature(f: function) {
    if f.hasreturntype { type_codegen(f.returntype); }
    else { printf("void "); }
    str_print(f.name);

    if f.paramslen == 0 {
        printf("(void)");
        return;
    }

    printf("(");
    let i: int = 0;
    for {
        if i == f.paramslen { break; }
        if i != 0 { printf(", "); }
        let p: param = *(f.params + i);
        type_codegen(p.type);
        str_print(p.name);
        i += 1;
    }
    printf(")");
}

fn strukt_codegen(s: strukt) {
    printf("struct ");
    str_print(s.name);
    printf(" {");

    if s.fieldslen == 0 {
        printf("};");
        return;
    }

    let i: int = 0;
    for {
        if i == s.fieldslen { break; }
        printf("\n    ");
        let f: field = *(s.fields + i);
        type_codegen(f.type);
        str_print(f.name);
        printf(";");
        i += 1;
    }
    printf("\n};");
}

fn strukt_codegenforwarddeclaration(s: strukt) {
    printf("typedef struct ");
    str_print(s.name);
    printf(" ");
    str_print(s.name);
    printf(";");
}

fn global_codegen(g: global) {
    printf("#define ");
    str_print(g.name);
    printf(" ");
    expr_codegen(g.val);
}

fn statement_codegen(s: statement, indentation: int) {
    if s.kind == STATEMENT_EXPR {
        expr_codegen(s.expr);
        printf(";");
    }

    if s.kind == STATEMENT_LET {
        type_codegen(s.type);
        str_print(s.name);
        if s.initialized {
            printf(" = ");
            expr_codegen(s.expr);
        }
        printf(";");
    }

    if s.kind == STATEMENT_FOR {
        printf("while (true) ");
        block_codegen(s.block, indentation);
    }

    if s.kind == STATEMENT_IF {
        printf("if (");
        expr_codegen(s.condition);
        printf(") ");
        block_codegen(s.block, indentation);
        if s.haselse {
            printf(" else ");
            block_codegen(s.elseblock, indentation);
        }
    }

    if s.kind == STATEMENT_RETURN {
        printf("return");
        if s.initialized {
            printf(" ");
            expr_codegen(s.expr);
        }
        printf(";");
    }

    if s.kind == STATEMENT_BREAK {
        printf("break;");
    }
}

fn block_codegen(b: block, indentation: int) {
    if b.len == 0 {
        printf("{}");
        return;
    }

    printf("{");

    let i: int = 0;
    for {
        if i == b.len { break; }
        newline(indentation + 1);
        statement_codegen(*(b.statements + i), indentation + 1);
        i += 1;
    }

    newline(indentation);
    printf("}");
}

fn type_codegen(t: type) {
    if t.kind == TYPE_NAMED {
        str_print(t.name);
        printf(" ");
    }

    if t.kind == TYPE_PTR {
        type_codegen(*t.pointsto);
        printf("*");
    }
}

fn expr_codegen(e: expr) {
    if e.kind == EXPR_INTLITERAL {
        printf("%d", e.value);
    }

    if e.kind == EXPR_LOCAL {
        str_print(e.name);
    }

    if e.kind == EXPR_BIN {
        printf("(");
        expr_codegen(*e.lhs);
        printf(" ");
        if e.op == OP_ADD { printf("+"); }
        if e.op == OP_SUB { printf("-"); }
        if e.op == OP_MUL { printf("*"); }
        if e.op == OP_DIV { printf("/"); }
        if e.op == OP_ASSIGN { printf("="); }
        if e.op == OP_ADDASSIGN { printf("+="); }
        if e.op == OP_SUBASSIGN { printf("-="); }
        if e.op == OP_MULASSIGN { printf("*="); }
        if e.op == OP_DIVASSIGN { printf("/="); }
        if e.op == OP_EQUAL { printf("=="); }
        if e.op == OP_NOTEQUAL { printf("!="); }
        if e.op == OP_AND { printf("&&"); }
        if e.op == OP_OR { printf("||"); }
        if e.op == OP_LTEQUAL { printf("<="); }
        if e.op == OP_GTEQUAL { printf(">="); }
        if e.op == OP_LT { printf("<"); }
        if e.op == OP_GT { printf(">"); }
        printf(" ");
        expr_codegen(*e.rhs);
        printf(")");
    }

    if e.kind == EXPR_NOT {
        printf("!");
        expr_codegen(*e.lhs);
    }

    if e.kind == EXPR_NEGATION {
        printf("-");
        expr_codegen(*e.lhs);
    }

    if e.kind == EXPR_CALL {
        str_print(e.name);
        printf("(");
        let i: int = 0;
        for {
            if i == e.numargs { break; }

            if i != 0 { printf(", "); }

            let arg: expr = *(e.args + i);
            expr_codegen(arg);

            i += 1;
        }
        printf(")");
    }

    if e.kind == EXPR_ADDROF {
        printf("&");
        expr_codegen(*e.lhs);
    }

    if e.kind == EXPR_DEREF {
        printf("*");
        expr_codegen(*e.lhs);
    }

    if e.kind == EXPR_FIELDACCESS {
        expr_codegen(*e.lhs);
        if e.throughptr { printf("->"); }
        else { printf("."); }
        str_print(e.name);
    }

    if e.kind == EXPR_CHARLITERAL {
        printf("'");
        str_print(e.name);
        printf("'");
    }

    if e.kind == EXPR_STRINGLITERAL {
        printf("\"");
        str_print(e.name);
        printf("\"");
    }
}

fn item_print(i: item) {
    if i.kind == ITEM_FUNCTION { function_print(i.function); }
    if i.kind == ITEM_STRUKT { strukt_print(i.strukt); }
    if i.kind == ITEM_GLOBAL { global_print(i.global); }
}

fn function_print(f: function) {
    printf("fn ");
    str_print(f.name);
    printf("(");
    let i: int = 0;
    for {
        if i == f.paramslen { break; }
        if i != 0 { printf(", "); }
        let p: param = *(f.params + i);
        str_print(p.name);
        printf(": ");
        type_print(p.type);
        i += 1;
    }
    printf(")");
    if f.hasreturntype {
        printf(" ");
        type_print(f.returntype);
    }
    printf(" ");
    block_print(f.body, 0);
}

fn strukt_print(s: strukt) {
    printf("struct ");
    str_print(s.name);
    printf(" {");

    if s.fieldslen == 0 {
        printf("}");
        return;
    }

    let i: int = 0;
    for {
        if i == s.fieldslen { break; }
        printf("\n    ");
        let f: field = *(s.fields + i);
        str_print(f.name);
        printf(": ");
        type_print(f.type);
        printf(",");
        i += 1;
    }
    printf("\n}");
}

fn global_print(g: global) {
    printf("let ");
    str_print(g.name);
    printf(" = ");
    expr_print(g.val);
    printf(";");
}

fn statement_print(s: statement, indentation: int) {
    if s.kind == STATEMENT_EXPR {
        expr_print(s.expr);
        printf(";");
    }

    if s.kind == STATEMENT_LET {
        printf("let ");
        str_print(s.name);
        printf(": ");
        type_print(s.type);
        if s.initialized {
            printf(" = ");
            expr_print(s.expr);
        }
        printf(";");
    }

    if s.kind == STATEMENT_FOR {
        printf("for ");
        block_print(s.block, indentation);
    }

    if s.kind == STATEMENT_IF {
        printf("if ");
        expr_print(s.condition);
        printf(" ");
        block_print(s.block, indentation);
        if s.haselse {
            printf(" else ");
            block_print(s.elseblock, indentation);
        }
    }

    if s.kind == STATEMENT_RETURN {
        printf("return");
        if s.initialized {
            printf(" ");
            expr_print(s.expr);
        }
        printf(";");
    }

    if s.kind == STATEMENT_BREAK {
        printf("break;");
    }
}

fn block_print(b: block, indentation: int) {
    if b.len == 0 {
        printf("{}");
        return;
    }

    printf("{");

    let i: int = 0;
    for {
        if i == b.len { break; }
        newline(indentation + 1);
        statement_print(*(b.statements + i), indentation + 1);
        i += 1;
    }

    newline(indentation);
    printf("}");
}

fn type_print(t: type) {
    if t.kind == TYPE_NAMED {
        str_print(t.name);
        return;
    }

    if t.kind == TYPE_PTR {
        printf("*");
        type_print(*t.pointsto);
    }
}

fn expr_print(e: expr) {
    if e.kind == EXPR_INTLITERAL {
        printf("%d", e.value);
    }

    if e.kind == EXPR_LOCAL {
        str_print(e.name);
    }

    if e.kind == EXPR_BIN {
        printf("(");
        expr_print(*e.lhs);
        printf(" ");
        if e.op == OP_ADD { printf("+"); }
        if e.op == OP_SUB { printf("-"); }
        if e.op == OP_MUL { printf("*"); }
        if e.op == OP_DIV { printf("/"); }
        if e.op == OP_ASSIGN { printf("="); }
        if e.op == OP_ADDASSIGN { printf("+="); }
        if e.op == OP_SUBASSIGN { printf("-="); }
        if e.op == OP_MULASSIGN { printf("*="); }
        if e.op == OP_DIVASSIGN { printf("/="); }
        if e.op == OP_EQUAL { printf("=="); }
        if e.op == OP_NOTEQUAL { printf("!="); }
        if e.op == OP_AND { printf("&&"); }
        if e.op == OP_OR { printf("||"); }
        if e.op == OP_LTEQUAL { printf("<="); }
        if e.op == OP_GTEQUAL { printf(">="); }
        if e.op == OP_LT { printf("<"); }
        if e.op == OP_GT { printf(">"); }
        printf(" ");
        expr_print(*e.rhs);
        printf(")");
    }

    if e.kind == EXPR_NOT {
        printf("!(");
        expr_print(*e.lhs);
        printf(")");
    }

    if e.kind == EXPR_NEGATION {
        printf("-(");
        expr_print(*e.lhs);
        printf(")");
    }

    if e.kind == EXPR_CALL {
        str_print(e.name);
        printf("(");
        let i: int = 0;
        for {
            if i == e.numargs { break; }

            if i != 0 { printf(", "); }

            let arg: expr = *(e.args + i);
            expr_print(arg);

            i += 1;
        }
        printf(")");
    }

    if e.kind == EXPR_ADDROF {
        printf("&(");
        expr_print(*e.lhs);
        printf(")");
    }

    if e.kind == EXPR_DEREF {
        printf("*(");
        expr_print(*e.lhs);
        printf(")");
    }

    if e.kind == EXPR_FIELDACCESS {
        printf("(");
        expr_print(*e.lhs);
        printf(")");
        if e.throughptr { printf("->"); }
        else { printf("."); }
        str_print(e.name);
    }

    if e.kind == EXPR_CHARLITERAL {
        printf("'");
        str_print(e.name);
        printf("'");
    }

    if e.kind == EXPR_STRINGLITERAL {
        printf("\"");
        str_print(e.name);
        printf("\"");
    }
}

fn newline(indentation: int) {
    printf("\n");
    let i: int = 0;
    for {
        if i == indentation { break; }
        printf("    ");
        i += 1;
    }
}

fn str_new(cs: *char) str {
    let s: str;

    s.len = 0;
    for {
        if *(cs + s.len) == 0 { break; }
        s.len += 1;
    }

    s.data = cs;
    return s;
}

fn str_equal(l: str, r: str) bool {
    if l.len != r.len { return false; }
    let i: int = 0;
    for {
        if i == l.len { break; }
        if *(l.data + i) != *(r.data + i) { return false; }
        i += 1;
    }
    return true;
}

fn str_print(s: str) {
    let i: int = 0;
    for {
        if i == s.len { break; }
        printf("%c", *(s.data + i));
        i += 1;
    }
}

fn iswhitespace(c: char) bool {
    return c == ' ' || c == '\n';
}

fn isasciidigit(c: char) bool {
    return c >= '0' && c <= '9';
}

fn isasciialphabetic(c: char) bool {
    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
}

fn isidentfirst(c: char) bool {
    return isasciialphabetic(c) || c == '_';
}

fn isidentfollow(c: char) bool {
    return isidentfirst(c) || isasciidigit(c);
}
