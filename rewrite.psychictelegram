fn main() int {
    tests();
}

struct str { ptr *char, len int }
struct range { start int, len int }

fn str_new(nullterminated *char) str {
    let lenprefixed str;
    lenprefixed.ptr = nullterminated;
    lenprefixed.len = strlen(nullterminated);
    return lenprefixed;
}

fn str_empty() str {
    let s str;
    s.ptr = 0;
    s.len = 0;
    return s;
}

fn str_equal(s1 str, nullterminated *char) bool {
    return str_equalstr(s1, str_new(nullterminated));
}

fn str_equalstr(s1 str, s2 str) bool {
    if s1.len != s2.len { return false; }
    let i int = 0;
    for {
        if i > s1.len { break; }
        let c1 char = *(s1.ptr + i);
        let c2 char = *(s2.ptr + i);
        if c1 != c2 { return false; }
        i += 1;
    }
    return true;
}

fn str_prettyequal(actual str, expectednullterminated *char) bool {
    let expected str = str_new(expectednullterminated);

    if str_equalstr(actual, expected) { return true; }

    printf("\x1B[91mstrings not equal!\x1B[0m");

    printf("\n");
    printf("\nactual");
    printf("\n──────");
    printf("\n\x1B[94m");
    str_print(actual);
    printf("\x1B[0m");
    printf("\n──────");

    printf("\n");
    printf("\nexpected");
    printf("\n──────");
    printf("\n\x1B[95m");
    str_print(expected);
    printf("\x1B[0m");
    printf("\n──────");

    printf("\n");
    printf("\ndiff");
    printf("\n──────");
    for {
        if actual.len == 0 && expected.len == 0 { break; }
        if actual.len == 0 {
            let line str = str_eatline(&expected);
            printf("\n\x1B[95m");
            str_print(line);
            printf("\x1B[0m");
        } else {
            if expected.len == 0 {
                let line str = str_eatline(&actual);
                printf("\n\x1B[94m");
                str_print(line);
                printf("\x1B[0m");
            } else {
                let actualline str = str_eatline(&actual);
                let expectedline str = str_eatline(&expected);
                if str_equalstr(actualline, expectedline) {
                    printf("\n");
                    str_print(actualline);
                } else {
                    printf("\n\x1B[94m");
                    str_print(actualline);
                    printf("\n\x1B[95m");
                    str_print(expectedline);
                    printf("\x1B[0m");
                }
            }
        }
    }

    printf("\n");
    printf("──────\n");

    return false;
}

fn str_eatline(s *str) str {
    let newlineidx int = 0;
    let reachedend bool = false;
    for {
        if newlineidx == s->len {
            reachedend = true;
            break;
        }
        newlineidx += 1;
        if *(s->ptr + newlineidx - 1) == '\n' { break; }
    }

    let line str;
    line.ptr = s->ptr;
    line.len = newlineidx;
    if !reachedend { line.len -= 1; }
    s->ptr += newlineidx;
    s->len -= newlineidx;

    return line;
}

fn str_print(s str) {
    let i int = 0;
    for {
        if i == s.len { break; }
        printf("%c", *(s.ptr + i));
        i += 1;
    }
}

fn range_equal(r range, start int, len int) bool {
    return r.start == start && r.len == len;
}

fn range_print(r range) {
    printf("\x1B[92m%d\x1B[0m..\x1B[92m%d\x1B[0m", r.start, r.start + r.len);
}

fn tests() {
    printf("--> LEXER\n"); test_lexer();
    printf("--> SYNTAX\n"); test_syntax();
    printf("--> PARSER\n"); test_parser();
    printf("--> INDEXING\n"); test_indexing();
}

struct lexer { text str, range range }
struct token { kind char, range range }
struct tokens { ptr *token, len int }

let SK_EOF = 0;
let SK_ERROR = 1;
let SK_WS = 2;
let SK_NUMBER = 3;
let SK_IDENT = 4;
let SK_STRING = 5;
let SK_RAWSTRING = 6;
let SK_CHAR = 7;
let SK_DOT = 8;
let SK_COLON = 9;
let SK_COMMA = 10;
let SK_SEMI = 11;
let SK_LPAREN = 12;
let SK_RPAREN = 13;
let SK_LBRACE = 14;
let SK_RBRACE = 15;
let SK_PLUS = 16;
let SK_HYPHEN = 17;
let SK_STAR = 18;
let SK_SLASH = 19;
let SK_EQUAL = 20;
let SK_BANG = 21;
let SK_PRETZEL = 22;
let SK_PIPE = 23;
let SK_LT = 24;
let SK_GT = 25;
let SK_FNKW = 26;
let SK_STRUCTKW = 27;
let SK_LETKW = 28;
let SK_IFKW = 29;
let SK_ELSEKW = 30;
let SK_FORKW = 31;
let SK_BREAKKW = 32;
let SK_RETURNKW = 33;
let SK_EXTERNKW = 34;
let SK_COMMENT = 35;

let SK_ROOT = -1;
let SK_FUNCTION = -2;
let SK_TYPE = -3;
let SK_PARAM = -4;
let SK_BLOCK = -5;
let SK_EXPRSTMT = -6;
let SK_RAWSTRINGLITERAL = -7;
let SK_LETSTMT = -8;
let SK_VARIABLE = -9;
let SK_CALL = -10;
let SK_STRUKT = -11;
let SK_FIELD = -12;
let SK_CONSTANT = -13;
let SK_RETURNSTMT = -14;
let SK_BREAKSTMT = -15;
let SK_FORSTMT = -16;
let SK_IFSTMT = -17;
let SK_BINARYEXPR = -18;
let SK_PARENEXPR = -19;
let SK_PREFIXEXPR = -20;
let SK_FIELDEXPR = -21;
let SK_XTERN = -22;

fn syntaxkind_print(k char) {
    printf("\x1B[94m");
    str_print(syntaxkind_format(k));
    printf("\x1B[0m");
}

fn syntaxkind_format(k char) str {
    if k == 0 { return str_new("EOF"); }
    if k == 1 { return str_new("ERROR"); }
    if k == 2 { return str_new("WS"); }
    if k == 3 { return str_new("NUMBER"); }
    if k == 4 { return str_new("IDENT"); }
    if k == 5 { return str_new("STRING"); }
    if k == 6 { return str_new("RAWSTRING"); }
    if k == 7 { return str_new("CHAR"); }
    if k == 8 { return str_new("DOT"); }
    if k == 9 { return str_new("COLON"); }
    if k == 10 { return str_new("COMMA"); }
    if k == 11 { return str_new("SEMI"); }
    if k == 12 { return str_new("LPAREN"); }
    if k == 13 { return str_new("RPAREN"); }
    if k == 14 { return str_new("LBRACE"); }
    if k == 15 { return str_new("RBRACE"); }
    if k == 16 { return str_new("PLUS"); }
    if k == 17 { return str_new("HYPHEN"); }
    if k == 18 { return str_new("STAR"); }
    if k == 19 { return str_new("SLASH"); }
    if k == 20 { return str_new("EQUAL"); }
    if k == 21 { return str_new("BANG"); }
    if k == 22 { return str_new("PRETZEL"); }
    if k == 23 { return str_new("PIPE"); }
    if k == 24 { return str_new("LT"); }
    if k == 25 { return str_new("GT"); }
    if k == 26 { return str_new("FNKW"); }
    if k == 27 { return str_new("STRUCTKW"); }
    if k == 28 { return str_new("LETKW"); }
    if k == 29 { return str_new("IFKW"); }
    if k == 30 { return str_new("ELSEKW"); }
    if k == 31 { return str_new("FORKW"); }
    if k == 32 { return str_new("BREAKKW"); }
    if k == 33 { return str_new("RETURNKW"); }
    if k == 34 { return str_new("EXTERNKW"); }
    if k == 35 { return str_new("COMMENT"); }
    if k == -1 { return str_new("ROOT"); }
    if k == -2 { return str_new("FUNCTION"); }
    if k == -3 { return str_new("TYPE"); }
    if k == -4 { return str_new("PARAM"); }
    if k == -5 { return str_new("BLOCK"); }
    if k == -6 { return str_new("EXPRSTMT"); }
    if k == -7 { return str_new("RAWSTRINGLITERAL"); }
    if k == -8 { return str_new("LETSTMT"); }
    if k == -9 { return str_new("VARIABLE"); }
    if k == -10 { return str_new("CALL"); }
    if k == -11 { return str_new("STRUKT"); }
    if k == -12 { return str_new("FIELD"); }
    if k == -13 { return str_new("CONSTANT"); }
    if k == -14 { return str_new("RETURNSTMT"); }
    if k == -15 { return str_new("BREAKSTMT"); }
    if k == -16 { return str_new("FORSTMT"); }
    if k == -17 { return str_new("IFSTMT"); }
    if k == -18 { return str_new("BINARYEXPR"); }
    if k == -19 { return str_new("PARENEXPR"); }
    if k == -20 { return str_new("PREFIXEXPR"); }
    if k == -21 { return str_new("FIELDEXPR"); }
    if k == -22 { return str_new("XTERN"); }

    printf("bad syntaxkind\n");
    exit(1);
}

fn lex(text str) tokens {
    let cap int = 8;
    let tokens tokens;
    tokens.ptr = malloc(cap * sizeof(token));
    tokens.len = 0;

    let l lexer = lexer_new(text);

    for {
        let t token = lexer_next(&l);
        if t.kind == SK_EOF { break; }

        if tokens.len == cap {
            cap *= 2;
            tokens.ptr = realloc(tokens.ptr, cap * sizeof(token));
        }
        *(tokens.ptr + tokens.len) = t;
        tokens.len += 1;
    }

    return tokens;
}

fn lexer_new(text str) lexer {
    let l lexer;
    l.text = text;
    l.range.start = 0;
    l.range.len = 0;
    return l;
}

fn lexer_next(l *lexer) token {
    if lexer_ateof(l) {
        let t token;
        t.kind = SK_EOF;
        t.range.start = 0;
        t.range.len = 0;
        return t;
    }

    if lexer_atws(l) { return lexer_ws(l); }
    if lexer_atdigit(l) { return lexer_number(l); }
    if lexer_atalpha(l) { return lexer_ident(l); }
    if lexer_current(l) == '"' { return lexer_delimited(l, '"', SK_STRING); }
    if lexer_current(l) == 39 { return lexer_delimited(l, 39, SK_CHAR); }
    if lexer_current(l) == '\\' { return lexer_rawstring(l); }
    if lexer_current(l) == '#' { return lexer_comment(l); }

    if lexer_current(l) == '.' {
        l->range.len += 1;
        return lexer_emit(l, SK_DOT);
    }
    if lexer_current(l) == ':' {
        l->range.len += 1;
        return lexer_emit(l, SK_COLON);
    }
    if lexer_current(l) == ',' {
        l->range.len += 1;
        return lexer_emit(l, SK_COMMA);
    }
    if lexer_current(l) == ';' {
        l->range.len += 1;
        return lexer_emit(l, SK_SEMI);
    }
    if lexer_current(l) == '(' {
        l->range.len += 1;
        return lexer_emit(l, SK_LPAREN);
    }
    if lexer_current(l) == ')' {
        l->range.len += 1;
        return lexer_emit(l, SK_RPAREN);
    }
    if lexer_current(l) == '{' {
        l->range.len += 1;
        return lexer_emit(l, SK_LBRACE);
    }
    if lexer_current(l) == '}' {
        l->range.len += 1;
        return lexer_emit(l, SK_RBRACE);
    }
    if lexer_current(l) == '+' {
        l->range.len += 1;
        return lexer_emit(l, SK_PLUS);
    }
    if lexer_current(l) == '-' {
        l->range.len += 1;
        return lexer_emit(l, SK_HYPHEN);
    }
    if lexer_current(l) == '*' {
        l->range.len += 1;
        return lexer_emit(l, SK_STAR);
    }
    if lexer_current(l) == '/' {
        l->range.len += 1;
        return lexer_emit(l, SK_SLASH);
    }
    if lexer_current(l) == '=' {
        l->range.len += 1;
        return lexer_emit(l, SK_EQUAL);
    }
    if lexer_current(l) == '!' {
        l->range.len += 1;
        return lexer_emit(l, SK_BANG);
    }
    if lexer_current(l) == '&' {
        l->range.len += 1;
        return lexer_emit(l, SK_PRETZEL);
    }
    if lexer_current(l) == '|' {
        l->range.len += 1;
        return lexer_emit(l, SK_PIPE);
    }
    if lexer_current(l) == '<' {
        l->range.len += 1;
        return lexer_emit(l, SK_LT);
    }
    if lexer_current(l) == '>' {
        l->range.len += 1;
        return lexer_emit(l, SK_GT);
    }

    l->range.len += 1;
    return lexer_emit(l, SK_ERROR);
}

fn lexer_ws(l *lexer) token {
    for {
        if lexer_ateof(l) || !lexer_atws(l) { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_WS);
}

fn lexer_number(l *lexer) token {
    for {
        if lexer_ateof(l) || !lexer_atdigit(l) { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_NUMBER);
}

fn lexer_ident(l *lexer) token {
    for {
        if lexer_ateof(l) ||
            !(
                lexer_atalpha(l) ||
                lexer_atdigit(l) ||
                lexer_current(l) == '_'
            ) { break; }
        l->range.len += 1;
    }

    let text str = lexer_text(l);
    if str_equal(text, "fn") { return lexer_emit(l, SK_FNKW); }
    if str_equal(text, "struct") { return lexer_emit(l, SK_STRUCTKW); }
    if str_equal(text, "let") { return lexer_emit(l, SK_LETKW); }
    if str_equal(text, "if") { return lexer_emit(l, SK_IFKW); }
    if str_equal(text, "else") { return lexer_emit(l, SK_ELSEKW); }
    if str_equal(text, "for") { return lexer_emit(l, SK_FORKW); }
    if str_equal(text, "break") { return lexer_emit(l, SK_BREAKKW); }
    if str_equal(text, "return") { return lexer_emit(l, SK_RETURNKW); }
    if str_equal(text, "extern") { return lexer_emit(l, SK_EXTERNKW); }

    return lexer_emit(l, SK_IDENT);
}

fn lexer_delimited(l *lexer, delimiter char, kind char) token {
    l->range.len += 1;
    for {
        let inescape bool = !lexer_ateof(l) && lexer_current(l) == '\\';
        if inescape { l->range.len += 1; }

        if lexer_ateof(l) { return lexer_emit(l, SK_ERROR); }
        if lexer_current(l) == '\n' { return lexer_emit(l, SK_ERROR); }
        if lexer_current(l) == delimiter && !inescape { break; }
        l->range.len += 1;
    }
    l->range.len += 1;
    return lexer_emit(l, kind);
}

fn lexer_rawstring(l *lexer) token {
    for {
        if lexer_ateof(l) || lexer_current(l) == '\n' { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_RAWSTRING);
}

fn lexer_comment(l *lexer) token {
    for {
        if lexer_ateof(l) || lexer_current(l) == '\n' { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_COMMENT);
}

fn lexer_atws(l *lexer) bool {
    return lexer_current(l) == ' ' || lexer_current(l) == '\n';
}

fn lexer_atdigit(l *lexer) bool {
    return lexer_current(l) >= '0' && lexer_current(l) <= '9';
}

fn lexer_atalpha(l *lexer) bool {
    return lexer_current(l) >= 'a' && lexer_current(l) <= 'z' ||
        lexer_current(l) >= 'A' && lexer_current(l) <= 'Z';
}

fn lexer_emit(l *lexer, kind char) token {
    let t token;
    t.kind = kind;
    t.range = l->range;

    l->range.start += l->range.len;
    l->range.len = 0;

    return t;
}

fn lexer_text(l *lexer) str {
    let s str;
    s.ptr = l->text.ptr + l->range.start;
    s.len = l->range.len;
    return s;
}

fn lexer_current(l *lexer) char {
    assert(!lexer_ateof(l));
    return *(l->text.ptr + l->range.start + l->range.len);
}

fn lexer_ateof(l *lexer) bool {
    return l->range.start + l->range.len >= l->text.len;
}

fn token_equal(t token, kind char, start int, len int) bool {
    return range_equal(t.range, start, len) && t.kind == kind;
}

fn token_print(t token) {
    printf("{ ");
    syntaxkind_print(t.kind);
    printf(", ");
    range_print(t.range);
    printf(" }\n");
}

fn test_lexer() {
    printf("    test empty\n"); test_lexer_empty();
    printf("    test ws\n"); test_lexer_ws();
    printf("    test number\n"); test_lexer_number();
    printf("    test numbers\n"); test_lexer_numbers();
    printf("    test idents\n"); test_lexer_idents();
    printf("    test strings\n"); test_lexer_strings();
    printf("    test no_multiline_strings\n"); test_lexer_no_multiline_strings();
    printf("    test unclosed_string\n"); test_lexer_unclosed_string();
    printf("    test no_escape_newline\n"); test_lexer_no_escape_newline();
    printf("    test char\n"); test_lexer_char();
    printf("    test symbols\n"); test_lexer_symbols();
    printf("    test keywords\n"); test_lexer_keywords();
    printf("    test comments\n"); test_lexer_comments();
    printf("    test rawstrings\n"); test_lexer_rawstrings();
}

fn test_lexer_empty() {
    let l lexer = lexer_new(str_empty());
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_ws() {
    let l lexer = lexer_new(str_new("  \n \n"));
    assert(token_equal(lexer_next(&l), SK_WS, 0, 5));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_number() {
    let l lexer = lexer_new(str_new("92"));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 0, 2));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_numbers() {
    let l lexer = lexer_new(str_new("1 2\n33 44"));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 0, 1));
    assert(token_equal(lexer_next(&l), SK_WS, 1, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 2, 1));
    assert(token_equal(lexer_next(&l), SK_WS, 3, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 4, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 6, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 7, 2));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_idents() {
    let l lexer = lexer_new(str_new("abc d EFG_H fnbAR01if6"));
    assert(token_equal(lexer_next(&l), SK_IDENT, 0, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 3, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 4, 1));
    assert(token_equal(lexer_next(&l), SK_WS, 5, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 6, 5));
    assert(token_equal(lexer_next(&l), SK_WS, 11, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 12, 10));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_strings() {
    let l lexer = lexer_new(str_new("\"\" \"?\" \"\\n\" \"\\\"\""));
    assert(token_equal(lexer_next(&l), SK_STRING, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_STRING, 3, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 6, 1));
    assert(token_equal(lexer_next(&l), SK_STRING, 7, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 11, 1));
    assert(token_equal(lexer_next(&l), SK_STRING, 12, 4));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_no_multiline_strings() {
    let l lexer = lexer_new(str_new("\"a\nb\""));
    assert(token_equal(lexer_next(&l), SK_ERROR, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 3, 1));
    assert(token_equal(lexer_next(&l), SK_ERROR, 4, 1));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_unclosed_string() {
    let l lexer = lexer_new(str_new("\"foo"));
    assert(token_equal(lexer_next(&l), SK_ERROR, 0, 4));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_no_escape_newline() {
    let l lexer = lexer_new(str_new("\"\\\n92"));
    assert(token_equal(lexer_next(&l), SK_ERROR, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 3, 2));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_char() {
    let l lexer = lexer_new(str_new("'a' '\\n' '\\\\' 'foo' '\\''"));
    assert(token_equal(lexer_next(&l), SK_CHAR, 0, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 3, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 4, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 8, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 9, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 13, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 14, 5));
    assert(token_equal(lexer_next(&l), SK_WS, 19, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 20, 4));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_symbols() {
    let l lexer = lexer_new(str_new(".:,;(){}+-*/=!&|<>"));
    assert(token_equal(lexer_next(&l), SK_DOT, 0, 1));
    assert(token_equal(lexer_next(&l), SK_COLON, 1, 1));
    assert(token_equal(lexer_next(&l), SK_COMMA, 2, 1));
    assert(token_equal(lexer_next(&l), SK_SEMI, 3, 1));
    assert(token_equal(lexer_next(&l), SK_LPAREN, 4, 1));
    assert(token_equal(lexer_next(&l), SK_RPAREN, 5, 1));
    assert(token_equal(lexer_next(&l), SK_LBRACE, 6, 1));
    assert(token_equal(lexer_next(&l), SK_RBRACE, 7, 1));
    assert(token_equal(lexer_next(&l), SK_PLUS, 8, 1));
    assert(token_equal(lexer_next(&l), SK_HYPHEN, 9, 1));
    assert(token_equal(lexer_next(&l), SK_STAR, 10, 1));
    assert(token_equal(lexer_next(&l), SK_SLASH, 11, 1));
    assert(token_equal(lexer_next(&l), SK_EQUAL, 12, 1));
    assert(token_equal(lexer_next(&l), SK_BANG, 13, 1));
    assert(token_equal(lexer_next(&l), SK_PRETZEL, 14, 1));
    assert(token_equal(lexer_next(&l), SK_PIPE, 15, 1));
    assert(token_equal(lexer_next(&l), SK_LT, 16, 1));
    assert(token_equal(lexer_next(&l), SK_GT, 17, 1));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_keywords() {
    let l lexer = lexer_new(str_new(
        \fn struct let if for break return else extern
    ));
    assert(token_equal(lexer_next(&l), SK_FNKW, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_STRUCTKW, 3, 6));
    assert(token_equal(lexer_next(&l), SK_WS, 9, 1));
    assert(token_equal(lexer_next(&l), SK_LETKW, 10, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 13, 1));
    assert(token_equal(lexer_next(&l), SK_IFKW, 14, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 16, 1));
    assert(token_equal(lexer_next(&l), SK_FORKW, 17, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 20, 1));
    assert(token_equal(lexer_next(&l), SK_BREAKKW, 21, 5));
    assert(token_equal(lexer_next(&l), SK_WS, 26, 1));
    assert(token_equal(lexer_next(&l), SK_RETURNKW, 27, 6));
    assert(token_equal(lexer_next(&l), SK_WS, 33, 1));
    assert(token_equal(lexer_next(&l), SK_ELSEKW, 34, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 38, 1));
    assert(token_equal(lexer_next(&l), SK_EXTERNKW, 39, 6));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_comments() {
    let l lexer = lexer_new(str_new("# hello\n123#456"));
    assert(token_equal(lexer_next(&l), SK_COMMENT, 0, 7));
    assert(token_equal(lexer_next(&l), SK_WS, 7, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 8, 3));
    assert(token_equal(lexer_next(&l), SK_COMMENT, 11, 4));
}

fn test_lexer_rawstrings() {
    let l lexer = lexer_new(str_new("\\foo\n\\quux"));
    assert(token_equal(lexer_next(&l), SK_RAWSTRING, 0, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 4, 1));
    assert(token_equal(lexer_next(&l), SK_RAWSTRING, 5, 5));
}

struct syntaxchild {
    istoken bool,
    kind char,
    range range,
    next *syntaxchild,
    child *syntaxchild,
    parent *syntaxchild,
}

struct syntaxtree { root *syntaxchild }

struct syntaxbuilder {
    root *syntaxchild,
    current *syntaxchild,
    inputidx int,
}

fn syntaxbuilder_new() syntaxbuilder {
    let b syntaxbuilder;
    b.root = 0;
    b.current = 0;
    b.inputidx = 0;
    return b;
}

fn syntaxbuilder_startnode(b *syntaxbuilder, kind char) {
    let new syntaxchild;
    new.istoken = false;
    new.kind = kind;
    new.range.start = b->inputidx;
    new.range.len = 0;
    new.next = 0;
    new.child = 0;
    new.parent = b->current;

    let newallocated *syntaxchild = malloc(sizeof(syntaxchild));
    *newallocated = new;

    if b->current == 0 {
        b->current = newallocated;
        b->root = newallocated;
    } else {
        syntaxchild_addchild(b->current, newallocated);
        b->current = newallocated;
    }
}

fn syntaxbuilder_addtoken(b *syntaxbuilder, kind char, len int) {
    let child *syntaxchild = malloc(sizeof(syntaxchild));
    child->istoken = true;
    child->kind = kind;
    child->range.start = b->inputidx;
    child->range.len = len;
    child->next = 0;
    child->child = 0;
    child->parent = b->current;
    syntaxchild_addchild(b->current, child);
    b->inputidx += len;
}

fn syntaxbuilder_finishnode(b *syntaxbuilder) {
    b->current->range.len = b->inputidx - b->current->range.start;
    b->current = b->current->parent;
}

fn syntaxbuilder_finish(b syntaxbuilder) syntaxtree {
    let t syntaxtree;
    t.root = b.root;
    return t;
}

fn syntaxchild_addchild(c *syntaxchild, newchild *syntaxchild) {
    let placetoinsert **syntaxchild = &c->child;
    for {
        if *placetoinsert == 0 { break; }
        let c *syntaxchild = *placetoinsert;
        placetoinsert = &c->next;
    }
    *placetoinsert = newchild;
}

fn syntaxchild_findchild(c *syntaxchild, kind char) *syntaxchild {
    let child *syntaxchild = c->child;
    for {
        if child == 0 { break; }
        if child->kind == kind { return child; }
        child = child->next;
    }
    return 0;
}

fn syntaxtree_print(t syntaxtree, text *char) {
    syntaxchild_print(t.root, text);
}

fn syntaxchild_print(child *syntaxchild, text *char) {
    let top *syntaxchild = child->parent;
    let indentation int = 0;
    let current syntaxchild = *child;

    for {
        let i int = 0;
        for {
            if i == indentation { break; }
            printf("\x1B[90m│\x1B[0m ");
            i += 1;
        }

        syntaxkind_print(current.kind);
        printf(" ");
        range_print(current.range);

        if current.istoken {
            printf(" \x1B[35m\"");
            printf("\x1B[95m");
            let i int = 0;
            for {
                if i == current.range.len { break; }

                let c char = *(text + current.range.start + i);
                if c == '\n'
                    { printf("\\n"); }
                else
                    { printf("%c", c); }

                i += 1;
            }
            printf("\x1B[35m\"");
        }

        printf("\x1B[0m\n");

        if current.child == 0 {
            let c syntaxchild = current;
            for {
                if c.next != 0 { break; }
                if c.parent == top { return; }
                c = *c.parent;
                indentation -= 1;
            }
            current = *c.next;
        } else {
            current = *current.child;
            indentation += 1;
        }
    }
}

fn syntaxtree_format(t syntaxtree, text *char) str {
    let s str;
    s.ptr = malloc(1024);
    s.len = 0;

    let indentation int = 0;
    let current syntaxchild = *t.root;

    for {
        if indentation != 0 {
            *(s.ptr + s.len) = '\n';
            s.len += 1;
        }

        let i int = 0;
        for {
            if i == indentation { break; }

            *(s.ptr + s.len) = ' ';
            s.len += 1;
            *(s.ptr + s.len) = ' ';
            s.len += 1;

            i += 1;
        }

        let kind str = syntaxkind_format(current.kind);
        memcpy(s.ptr + s.len, kind.ptr, kind.len);
        s.len += kind.len;

        if current.istoken {
            *(s.ptr + s.len) = ' ';
            s.len += 1;

            *(s.ptr + s.len) = '"';
            s.len += 1;

            let i int = 0;
            for {
                if i == current.range.len { break; }
                let c char = *(text + current.range.start + i);
                if c == '\n' {
                    *(s.ptr + s.len) = '\\';
                    s.len += 1;
                    *(s.ptr + s.len) = 'n';
                    s.len += 1;
                } else {
                    *(s.ptr + s.len) = c;
                    s.len += 1;
                }
                i += 1;
            }

            *(s.ptr + s.len) = '"';
            s.len += 1;
        }

        if current.child == 0 {
            let c syntaxchild = current;
            for {
                if c.next != 0 { break; }
                if c.parent == 0 { return s; }
                c = *c.parent;
                indentation -= 1;
            }
            current = *c.next;
        } else {
            current = *current.child;
            indentation += 1;
        }
    }

    return s;
}

fn test_syntax() {
    printf("    test empty\n"); test_syntax_empty();
    printf("    test addtoken\n"); test_syntax_addtoken();
    printf("    test root\n"); test_syntax_root();
    printf("    test links\n"); test_syntax_links();
    printf("    test format\n"); test_syntax_format();
}

fn test_syntax_empty() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, 0);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finish(b);
}

fn test_syntax_addtoken() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_addtoken(&b, SK_FORKW, 3);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finish(b);
}

fn test_syntax_root() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_addtoken(&b, SK_WS, 1);
    syntaxbuilder_addtoken(&b, SK_WS, 1);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);
    let root syntaxchild = *t.root;
    assert(range_equal(root.range, 0, 2));
    assert(root.kind == SK_ROOT);
}

fn test_syntax_links() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);
    let root syntaxchild = *t.root;

    let node1 syntaxchild = *root.child;
    assert(node1.kind == SK_FUNCTION);
    assert(range_equal(node1.range, 0, 3));

    let node1child1 syntaxchild = *node1.child;
    assert(node1child1.kind == SK_FNKW);
    assert(range_equal(node1child1.range, 0, 2));

    let node1child2 syntaxchild = *node1child1.next;
    assert(node1child2.kind == SK_IDENT);
    assert(range_equal(node1child2.range, 2, 1));

    assert(node1child2.next == 0);

    let node2 syntaxchild = *node1.next;
    assert(node1.kind == SK_FUNCTION);
    assert(range_equal(node2.range, 3, 3));

    let node2child1 syntaxchild = *node2.child;
    assert(node1child1.kind == SK_FNKW);
    assert(range_equal(node2child1.range, 3, 2));

    let node2child2 syntaxchild = *node2child1.next;
    assert(node1child2.kind == SK_IDENT);
    assert(range_equal(node2child2.range, 5, 1));

    assert(node2child2.next == 0);

    assert(node2.next == 0);
}

fn test_syntax_format() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);

    assert(str_prettyequal(
        syntaxtree_format(t, "fnafnb"),
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    IDENT "a"
        \  FUNCTION
        \    FNKW "fn"
        \    IDENT "b"
    ));
}

struct parseresult { tree syntaxtree, errorsptr *syntaxerror, errorslen int }

struct event { kind char, syntaxkind char }
let EVENT_STARTNODE = 1;
let EVENT_ADDTOKEN = 2;
let EVENT_FINISHNODE = 3;

struct syntaxerror { range range, message str }

struct parser {
    tokens tokens,
    tokenidx int,
    eventsptr *event,
    eventslen int,
    eventscap int,
    errorsptr *syntaxerror,
    errorslen int,
    errorscap int,
}

fn parse(text str) parseresult {
    let p parser = parser_new(text);
    grammar_root(&p);

    let builder syntaxbuilder = syntaxbuilder_new();

    let eventidx int = 0;
    let tokenidx int = 0;
    for {
        if eventidx == p.eventslen { break; }

        let e event = *(p.eventsptr + eventidx);
        if e.kind == EVENT_STARTNODE {
            syntaxbuilder_startnode(&builder, e.syntaxkind);
        }
        if e.kind == EVENT_ADDTOKEN {
            let t token = *(p.tokens.ptr + tokenidx);
            syntaxbuilder_addtoken(&builder, t.kind, t.range.len);
            tokenidx += 1;
        }
        if e.kind == EVENT_FINISHNODE {
            syntaxbuilder_finishnode(&builder);
        }

        if tokenidx < p.tokens.len {
            for {
                let t token = *(p.tokens.ptr + tokenidx);
                let istrivia bool = t.kind == SK_WS || t.kind == SK_COMMENT;
                if !istrivia { break; }
                syntaxbuilder_addtoken(&builder, t.kind, t.range.len);
                tokenidx += 1;
            }
        }

        eventidx += 1;
    }

    let result parseresult;
    result.tree = syntaxbuilder_finish(builder);
    result.errorsptr = p.errorsptr;
    result.errorslen = p.errorslen;
    return result;
}

fn grammar_root(p *parser) {
    parser_startnode(p, SK_ROOT);
    for {
        if parser_ateof(p) { break; }

        if parser_at(p, SK_FNKW) {
            grammar_function(p);
        } else {
            if parser_at(p, SK_STRUCTKW) {
                grammar_strukt(p);
            } else {
                if parser_at(p, SK_LETKW) {
                    grammar_constant(p);
                } else {
                    if parser_at(p, SK_EXTERNKW) {
                        grammar_xtern(p);
                    }
                }
            }
        }
    }
    parser_finishnode(p);
}

fn grammar_function(p *parser) {
    assert(parser_at(p, SK_FNKW));
    parser_startnode(p, SK_FUNCTION);
    parser_addtoken(p);

    parser_expect(p, SK_IDENT);

    parser_expect(p, SK_LPAREN);
    for {
        if parser_at(p, SK_RPAREN) { break; }
        parser_startnode(p, SK_PARAM);
        parser_expect(p, SK_IDENT);
        grammar_type(p);
        parser_finishnode(p);
        if parser_at(p, SK_RPAREN) { break; }
        parser_expect(p, SK_COMMA);
    }
    parser_addtoken(p);

    if !parser_at(p, SK_LBRACE) {
        grammar_type(p);
    }

    grammar_block(p);

    parser_finishnode(p);
}

fn grammar_strukt(p *parser) {
    assert(parser_at(p, SK_STRUCTKW));
    parser_startnode(p, SK_STRUKT);
    parser_addtoken(p);

    parser_expect(p, SK_IDENT);
    parser_expect(p, SK_LBRACE);

    for {
        if parser_at(p, SK_RBRACE) { break; }
        parser_startnode(p, SK_FIELD);
        parser_expect(p, SK_IDENT);
        grammar_type(p);
        parser_finishnode(p);
        if parser_at(p, SK_RBRACE) { break; }
        parser_expect(p, SK_COMMA);
    }
    parser_addtoken(p);

    parser_finishnode(p);
}

fn grammar_constant(p *parser) {
    assert(parser_at(p, SK_LETKW));
    parser_startnode(p, SK_CONSTANT);
    parser_addtoken(p);

    parser_expect(p, SK_IDENT);
    parser_expect(p, SK_EQUAL);
    grammar_expr(p);
    parser_expect(p, SK_SEMI);

    parser_finishnode(p);
}

fn grammar_xtern(p *parser) {
    assert(parser_at(p, SK_EXTERNKW));
    parser_startnode(p, SK_XTERN);
    parser_addtoken(p);

    if parser_at(p, SK_FNKW) || parser_at(p, SK_STRUCTKW) {
        parser_addtoken(p);
    } else {
        parser_error(
            p,
            (p->tokens.ptr + p->tokenidx - 1)->range,
            str_new("expected `fn` or `struct`"),
        );
    }

    parser_expect(p, SK_IDENT);
    parser_expect(p, SK_SEMI);

    parser_finishnode(p);
}

fn grammar_type(p *parser) {
    if parser_at(p, SK_IDENT) {
        parser_startnode(p, SK_TYPE);
        parser_addtoken(p);
        parser_finishnode(p);
        return;
    }

    if parser_at(p, SK_STAR) {
        parser_startnode(p, SK_TYPE);
        parser_addtoken(p);
        grammar_type(p);
        parser_finishnode(p);
        return;
    }

    parser_error(
        p,
        (p->tokens.ptr + p->tokenidx - 1)->range,
        str_new("expected type"),
    );
}

fn grammar_block(p *parser) {
    parser_startnode(p, SK_BLOCK);
    parser_expect(p, SK_LBRACE);
    for {
        if parser_ateof(p) || parser_at(p, SK_RBRACE) { break; }
        grammar_stmt(p);
    }
    parser_expect(p, SK_RBRACE);
    parser_finishnode(p);
}

fn grammar_stmt(p *parser) {
    if parser_at(p, SK_LETKW) { grammar_letstmt(p); return; }
    if parser_at(p, SK_RETURNKW) { grammar_returnstmt(p); return; }
    if parser_at(p, SK_BREAKKW) { grammar_breakstmt(p); return; }
    if parser_at(p, SK_FORKW) { grammar_forstmt(p); return; }
    if parser_at(p, SK_IFKW) { grammar_ifstmt(p); return; }

    parser_startnode(p, SK_EXPRSTMT);
    grammar_expr(p);
    parser_expect(p, SK_SEMI);
    parser_finishnode(p);
}

fn grammar_letstmt(p *parser) {
    assert(parser_at(p, SK_LETKW));
    parser_startnode(p, SK_LETSTMT);
    parser_addtoken(p);

    parser_expect(p, SK_IDENT);
    grammar_type(p);
    if parser_at(p, SK_EQUAL) {
        parser_addtoken(p);
        grammar_expr(p);
    }
    parser_expect(p, SK_SEMI);

    parser_finishnode(p);
}

fn grammar_returnstmt(p *parser) {
    assert(parser_at(p, SK_RETURNKW));
    parser_startnode(p, SK_RETURNSTMT);
    parser_addtoken(p);
    if !parser_at(p, SK_SEMI) { grammar_expr(p); }
    parser_expect(p, SK_SEMI);
    parser_finishnode(p);
}

fn grammar_breakstmt(p *parser) {
    assert(parser_at(p, SK_BREAKKW));
    parser_startnode(p, SK_BREAKSTMT);
    parser_addtoken(p);
    parser_expect(p, SK_SEMI);
    parser_finishnode(p);
}

fn grammar_forstmt(p *parser) {
    assert(parser_at(p, SK_FORKW));
    parser_startnode(p, SK_FORSTMT);
    parser_addtoken(p);
    grammar_block(p);
    parser_finishnode(p);
}

fn grammar_ifstmt(p *parser) {
    assert(parser_at(p, SK_IFKW));
    parser_startnode(p, SK_IFSTMT);
    parser_addtoken(p);
    grammar_expr(p);
    grammar_block(p);
    if parser_at(p, SK_ELSEKW) {
        parser_addtoken(p);
        grammar_block(p);
    }
    parser_finishnode(p);
}

fn grammar_expr(p *parser) {
    grammar_exprbp(p, 0);
}

fn grammar_exprbp(p *parser, minbp char) {
    let checkpoint checkpoint = parser_checkpoint(p);
    grammar_lhs(p);

    for {
        let opresult opresult = grammar_op(p);
        if opresult.bp == 0 { return; }

        if opresult.bp < minbp { break; }

        parser_startnodeat(p, checkpoint, SK_BINARYEXPR);

        let i int = 0;
        for {
            if i == opresult.numtokens { break; }
            parser_addtoken(p);
            i += 1;
        }

        grammar_exprbp(p, opresult.bp + 1);
        parser_finishnode(p);
    }
}

struct opresult { bp char, numtokens int }

fn grammar_op(p *parser) opresult {
    let r opresult;
    r.numtokens = 1;

    if parser_at(p, SK_PLUS) {
        if parser_lookahead(p) == SK_EQUAL {
            r.bp = 1;
            r.numtokens = 2;
            return r;
        }
        r.bp = 5;
        return r;
    }

    if parser_at(p, SK_HYPHEN) {
        if parser_lookahead(p) == SK_EQUAL {
            r.bp = 1;
            r.numtokens = 2;
            return r;
        }
        r.bp = 5;
        return r;
    }

    if parser_at(p, SK_STAR) {
        if parser_lookahead(p) == SK_EQUAL {
            r.bp = 1;
            r.numtokens = 2;
            return r;
        }
        r.bp = 6;
        return r;
    }

    if parser_at(p, SK_SLASH) {
        if parser_lookahead(p) == SK_EQUAL {
            r.bp = 1;
            r.numtokens = 2;
            return r;
        }
        r.bp = 6;
        return r;
    }

    if parser_at(p, SK_PRETZEL) {
        if parser_lookahead(p) == SK_PRETZEL {
            r.bp = 3;
            r.numtokens = 2;
            return r;
        }
    }

    if parser_at(p, SK_PIPE) {
        if parser_lookahead(p) == SK_PIPE {
            r.bp = 2;
            r.numtokens = 2;
            return r;
        }
    }

    if parser_at(p, SK_LT) || parser_at(p, SK_GT) {
        if parser_lookahead(p) == SK_EQUAL { r.numtokens = 2; }
        r.bp = 4;
        return r;
    }

    if parser_at(p, SK_EQUAL) {
        if parser_lookahead(p) == SK_EQUAL {
            r.bp = 4;
            r.numtokens = 2;
            return r;
        }
        r.bp = 1;
        return r;
    }

    if parser_at(p, SK_BANG) && parser_lookahead(p) == SK_EQUAL {
        r.bp = 4;
        r.numtokens = 2;
        return r;
    }

    r.bp = 0;
    return r;
}

fn grammar_lhs(p *parser) {
    let c checkpoint = parser_checkpoint(p);

    if parser_at(p, SK_NUMBER) {
        parser_addtoken(p);
        return grammar_fieldexpr(p, c);
    }

    if parser_at(p, SK_STRING) {
        parser_addtoken(p);
        return grammar_fieldexpr(p, c);
    }

    if parser_at(p, SK_RAWSTRING) {
        parser_startnode(p, SK_RAWSTRINGLITERAL);
        for {
            if !parser_at(p, SK_RAWSTRING) { break; }
            parser_addtoken(p);
        }
        parser_finishnode(p);
        return grammar_fieldexpr(p, c);
    }

    if parser_at(p, SK_CHAR) {
        parser_addtoken(p);
        return grammar_fieldexpr(p, c);
    }

    if parser_at(p, SK_IDENT) {
        if parser_lookahead(p) == SK_LPAREN {
            grammar_call(p);
            return grammar_fieldexpr(p, c);
        }
        parser_startnode(p, SK_VARIABLE);
        parser_addtoken(p);
        parser_finishnode(p);
        return grammar_fieldexpr(p, c);
    }

    if parser_at(p, SK_LPAREN) {
        parser_startnode(p, SK_PARENEXPR);
        parser_addtoken(p);
        grammar_expr(p);
        parser_expect(p, SK_RPAREN);
        parser_finishnode(p);
        return grammar_fieldexpr(p, c);
    }

    if
        parser_at(p, SK_PRETZEL) ||
        parser_at(p, SK_BANG) ||
        parser_at(p, SK_HYPHEN) ||
        parser_at(p, SK_STAR)
    {
        parser_startnode(p, SK_PREFIXEXPR);
        parser_addtoken(p);
        grammar_lhs(p);
        parser_finishnode(p);
        return grammar_fieldexpr(p, c);
    }

    parser_error(
        p,
        (p->tokens.ptr + p->tokenidx - 1)->range,
        str_new("expected expression"),
    );
}

fn grammar_fieldexpr(p *parser, c checkpoint) {
    for {
        if parser_at(p, SK_DOT) {
            parser_addtoken(p);
            parser_expect(p, SK_IDENT);
            parser_startnodeat(p, c, SK_FIELDEXPR);
            parser_finishnode(p);
        } else {
            if parser_at(p, SK_HYPHEN) && parser_lookahead(p) == SK_GT {
                parser_addtoken(p);
                parser_addtoken(p);
                parser_expect(p, SK_IDENT);
                parser_startnodeat(p, c, SK_FIELDEXPR);
                parser_finishnode(p);
            } else {
                break;
            }
        }
    }
}

fn grammar_call(p *parser) {
    assert(parser_at(p, SK_IDENT));
    parser_startnode(p, SK_CALL);
    parser_addtoken(p);
    assert(parser_at(p, SK_LPAREN));
    parser_addtoken(p);

    for {
        if parser_ateof(p) || parser_at(p, SK_RPAREN) { break; }
        grammar_expr(p);
        if parser_ateof(p) || parser_at(p, SK_RPAREN) { break; }
        parser_expect(p, SK_COMMA);
    }
    parser_addtoken(p);

    parser_finishnode(p);
}

fn parser_new(text str) parser {
    let p parser;

    p.tokens = lex(text);
    p.tokenidx = 0;

    let cap int = p.tokens.len * 2;
    p.eventsptr = malloc(cap * sizeof(event));
    p.eventslen = 0;
    p.eventscap = cap;

    p.errorsptr = malloc(8 * sizeof(syntaxerror));
    p.errorslen = 0;
    p.errorscap = 8;

    return p;
}

fn parser_expect(p *parser, kind char) {
    if parser_at(p, kind) {
        parser_addtoken(p);
        return;
    }

    let msg str;
    msg.ptr = malloc(1024);
    msg.len = 0;

    let s str = str_new("expected ");
    memcpy(msg.ptr + msg.len, s.ptr, s.len);
    msg.len += s.len;

    s = syntaxkind_format(kind);
    memcpy(msg.ptr + msg.len, s.ptr, s.len);
    msg.len += s.len;

    if parser_ateof(p) {
        parser_error(p, (p->tokens.ptr + p->tokenidx - 1)->range, msg);
        return;
    }

    s = str_new(" but found ");
    memcpy(msg.ptr + msg.len, s.ptr, s.len);
    msg.len += s.len;

    s = syntaxkind_format(parser_peek(p));
    memcpy(msg.ptr + msg.len, s.ptr, s.len);
    msg.len += s.len;

    parser_error(p, (p->tokens.ptr + p->tokenidx)->range, msg);
}

fn parser_at(p *parser, kind char) bool {
    parser_skiptrivia(p);
    return parser_rawat(p, kind);
}

fn parser_peek(p *parser) char {
    parser_skiptrivia(p);
    return parser_rawpeek(p);
}

fn parser_lookahead(p *parser) char {
    let i int = p->tokenidx;
    let passedfirst bool = false;
    for {
        assert(i < p->tokens.len);
        let kind char = (p->tokens.ptr + i)->kind;
        if kind != SK_WS && kind != SK_COMMENT {
            if passedfirst { return kind; }
            else { passedfirst = true; }
        }
        i += 1;
    }
}

struct checkpoint { idx int }

fn parser_checkpoint(p *parser) checkpoint {
    let c checkpoint;
    c.idx = p->eventslen;
    return c;
}

fn parser_startnodeat(p *parser, c checkpoint, kind char) {
    let e event;
    e.kind = EVENT_STARTNODE;
    e.syntaxkind = kind;
    parser_insertevent(p, e, c.idx);
}

fn parser_skiptrivia(p *parser) {
    for {
        if !(parser_rawat(p, SK_WS) || parser_rawat(p, SK_COMMENT)) { break; }
        p->tokenidx += 1;
    }
}

fn parser_rawat(p *parser, kind char) bool {
    if parser_ateof(p) { return false; }
    return parser_rawpeek(p) == kind;
}

fn parser_rawpeek(p *parser) char {
    assert(!parser_ateof(p));
    return (p->tokens.ptr + p->tokenidx)->kind;
}

fn parser_ateof(p *parser) bool {
    return p->tokenidx >= p->tokens.len;
}

fn parser_error(p *parser, range range, message str) {
    if p->errorslen == p->errorscap {
        p->errorscap *= 2;
        p->errorsptr = realloc(
            p->errorsptr,
            p->errorscap * sizeof(syntaxerror)
        );
    }

    let e syntaxerror;
    e.range = range;
    e.message = message;

    *(p->errorsptr + p->errorslen) = e;
    p->errorslen += 1;
}

fn parser_startnode(p *parser, kind char) {
    let e event;
    e.kind = EVENT_STARTNODE;
    e.syntaxkind = kind;
    parser_pushevent(p, e);
}

fn parser_addtoken(p *parser) {
    parser_skiptrivia(p);
    let e event;
    e.kind = EVENT_ADDTOKEN;
    parser_pushevent(p, e);
    p->tokenidx += 1;
}

fn parser_finishnode(p *parser) {
    let e event;
    e.kind = EVENT_FINISHNODE;
    parser_pushevent(p, e);
}

fn parser_insertevent(p *parser, e event, idx int) {
    parser_reserve1event(p);
    memmove(
        p->eventsptr + idx + 1,
        p->eventsptr + idx,
        (p->eventslen - idx) * sizeof(event),
    );
    *(p->eventsptr + idx) = e;
    p->eventslen += 1;
}

fn parser_pushevent(p *parser, e event) {
    parser_reserve1event(p);
    *(p->eventsptr + p->eventslen) = e;
    p->eventslen += 1;
}

fn parser_reserve1event(p *parser) {
    if p->eventslen == p->eventscap {
        p->eventscap *= 2;
        p->eventsptr = realloc(p->eventsptr, p->eventscap);
    }
}

fn test_parser() {
    printf("    test empty\n"); test_parser_empty();
    printf("    test emptyfunction\n"); test_parser_emptyfunction();
    printf("    test functionwithmissingname\n"); test_parser_functionwithmissingname();
    printf("    test functionwithreturntype\n"); test_parser_functionwithreturntype();
    printf("    test functionwithparameters\n"); test_parser_functionwithparameters();
    printf("    test functionwithparameterstrailingcomma\n"); test_parser_functionwithparameterstrailingcomma();
    printf("    test functionwithmissingparameterscomma\n"); test_parser_functionwithmissingparameterscomma();
    printf("    test multiplefunctions\n"); test_parser_multiplefunctions();
    printf("    test comments\n"); test_parser_comments();
    printf("    test unclosedfunctionbody\n"); test_parser_unclosedfunctionbody();
    printf("    test numberliterals\n"); test_parser_numberliterals();
    printf("    test stringliterals\n"); test_parser_stringliterals();
    printf("    test rawstringliterals\n"); test_parser_rawstringliterals();
    printf("    test charliterals\n"); test_parser_charliterals();
    printf("    test letstatement\n"); test_parser_letstatement();
    printf("    test variables\n"); test_parser_variables();
    printf("    test calls\n"); test_parser_calls();
    printf("    test pointertype\n"); test_parser_pointertype();
    printf("    test structs\n"); test_parser_structs();
    printf("    test constants\n"); test_parser_constants();
    printf("    test returnstatements\n"); test_parser_returnstatements();
    printf("    test breakstatement\n"); test_parser_breakstatement();
    printf("    test forloops\n"); test_parser_forloops();
    printf("    test ifstatements\n"); test_parser_ifstatements();
    printf("    test simplearithmetic\n"); test_parser_simplearithmetic();
    printf("    test booleanoperators\n"); test_parser_booleanoperators();
    printf("    test pointeroperators\n"); test_parser_pointeroperators();
    printf("    test fieldoperators\n"); test_parser_fieldoperators();
    printf("    test externitems\n"); test_parser_externitems();
}

fn test_parser_empty() {
    parsertestharness(
        \
        ,
        \ROOT
    );
}

fn test_parser_emptyfunction() {
    parsertestharness(
        \fn a() {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "a"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
    );
}

fn test_parser_functionwithmissingname() {
    parsertestharness(
        \fn () {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
        \error at 3..4: expected IDENT but found LPAREN
    );
}

fn test_parser_functionwithreturntype() {
    parsertestharness(
        \fn a() int {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "a"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    TYPE
        \      IDENT "int"
        \      WS " "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
    );
}

fn test_parser_functionwithparameters() {
    parsertestharness(
        \fn foo(x int, y int) {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "foo"
        \    LPAREN "("
        \    PARAM
        \      IDENT "x"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    COMMA ","
        \    WS " "
        \    PARAM
        \      IDENT "y"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
    );
}

fn test_parser_functionwithparameterstrailingcomma() {
    parsertestharness(
        \fn g(i int,) {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "g"
        \    LPAREN "("
        \    PARAM
        \      IDENT "i"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    COMMA ","
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
    );
}

fn test_parser_functionwithmissingparameterscomma() {
    parsertestharness(
        \fn a(a int b int) {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "a"
        \    LPAREN "("
        \    PARAM
        \      IDENT "a"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \        WS " "
        \    PARAM
        \      IDENT "b"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
        \error at 11..12: expected COMMA but found IDENT
    );
}

fn test_parser_multiplefunctions() {
    parsertestharness(
        \fn a() {}
        \fn b() {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "a"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
        \      WS "\n"
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "b"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
    );
}

fn test_parser_comments() {
    parsertestharness(
        \fn
        \    foo # function name
        \    (
        \        a int, # first parameter
        \        b int, # second parameter
        \    )
        \    {} # function body
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS "\n    "
        \    IDENT "foo"
        \    WS " "
        \    COMMENT "# function name"
        \    WS "\n    "
        \    LPAREN "("
        \    WS "\n        "
        \    PARAM
        \      IDENT "a"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    COMMA ","
        \    WS " "
        \    COMMENT "# first parameter"
        \    WS "\n        "
        \    PARAM
        \      IDENT "b"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    COMMA ","
        \    WS " "
        \    COMMENT "# second parameter"
        \    WS "\n    "
        \    RPAREN ")"
        \    WS "\n    "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
        \      WS " "
        \      COMMENT "# function body"
    );
}

fn test_parser_unclosedfunctionbody() {
    parsertestharness(
        \fn f() {
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "f"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \error at 7..8: expected RBRACE
    );
}

fn test_parser_numberliterals() {
    parsertestharness(
        \fn main() { 1; 2; }
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS " "
        \      EXPRSTMT
        \        NUMBER "1"
        \        SEMI ";"
        \        WS " "
        \      EXPRSTMT
        \        NUMBER "2"
        \        SEMI ";"
        \        WS " "
        \      RBRACE "}"
    );
}

fn test_parser_stringliterals() {
    parsertestharness(
        \fn main() { "foo"; "bar"; }
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS " "
        \      EXPRSTMT
        \        STRING ""foo""
        \        SEMI ";"
        \        WS " "
        \      EXPRSTMT
        \        STRING ""bar""
        \        SEMI ";"
        \        WS " "
        \      RBRACE "}"
    );
}

fn test_parser_rawstringliterals() {
    parsertestharness(
        \fn main() {
        \    \this is
        \    \a raw
        \    \string
        \    \literal
        \    ;
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      EXPRSTMT
        \        RAWSTRINGLITERAL
        \          RAWSTRING "\this is"
        \          WS "\n    "
        \          RAWSTRING "\a raw"
        \          WS "\n    "
        \          RAWSTRING "\string"
        \          WS "\n    "
        \          RAWSTRING "\literal"
        \          WS "\n    "
        \        SEMI ";"
        \        WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_charliterals() {
    parsertestharness(
        \fn main() { 'a'; 'b'; }
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS " "
        \      EXPRSTMT
        \        CHAR "'a'"
        \        SEMI ";"
        \        WS " "
        \      EXPRSTMT
        \        CHAR "'b'"
        \        SEMI ";"
        \        WS " "
        \      RBRACE "}"
    );
}

fn test_parser_letstatement() {
    parsertestharness(
        \fn main() {
        \    let x int = 10;
        \    let y int;
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      LETSTMT
        \        LETKW "let"
        \        WS " "
        \        IDENT "x"
        \        WS " "
        \        TYPE
        \          IDENT "int"
        \          WS " "
        \        EQUAL "="
        \        WS " "
        \        NUMBER "10"
        \        SEMI ";"
        \        WS "\n    "
        \      LETSTMT
        \        LETKW "let"
        \        WS " "
        \        IDENT "y"
        \        WS " "
        \        TYPE
        \          IDENT "int"
        \        SEMI ";"
        \        WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_variables() {
    parsertestharness(
        \fn main() { foo; bar; }
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS " "
        \      EXPRSTMT
        \        VARIABLE
        \          IDENT "foo"
        \        SEMI ";"
        \        WS " "
        \      EXPRSTMT
        \        VARIABLE
        \          IDENT "bar"
        \        SEMI ";"
        \        WS " "
        \      RBRACE "}"
    );
}

fn test_parser_calls() {
    parsertestharness(
        \fn main() {
        \    foo();
        \    bar(1, 2);
        \    baz(
        \        quux(),
        \        "bar",
        \    );
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      EXPRSTMT
        \        CALL
        \          IDENT "foo"
        \          LPAREN "("
        \          RPAREN ")"
        \        SEMI ";"
        \        WS "\n    "
        \      EXPRSTMT
        \        CALL
        \          IDENT "bar"
        \          LPAREN "("
        \          NUMBER "1"
        \          COMMA ","
        \          WS " "
        \          NUMBER "2"
        \          RPAREN ")"
        \        SEMI ";"
        \        WS "\n    "
        \      EXPRSTMT
        \        CALL
        \          IDENT "baz"
        \          LPAREN "("
        \          WS "\n        "
        \          CALL
        \            IDENT "quux"
        \            LPAREN "("
        \            RPAREN ")"
        \          COMMA ","
        \          WS "\n        "
        \          STRING ""bar""
        \          COMMA ","
        \          WS "\n    "
        \          RPAREN ")"
        \        SEMI ";"
        \        WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_pointertype() {
    parsertestharness(
        \fn f() *foo {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "f"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    TYPE
        \      STAR "*"
        \      TYPE
        \        IDENT "foo"
        \        WS " "
        \    BLOCK
        \      LBRACE "{"
        \      RBRACE "}"
    );
}

fn test_parser_structs() {
    parsertestharness(
        \struct a {}
        \struct b { foo bar }
        \struct c { foo bar, baz quux }
        \struct person {
        \    name *char,
        \    age int,
        \}
        ,
        \ROOT
        \  STRUKT
        \    STRUCTKW "struct"
        \    WS " "
        \    IDENT "a"
        \    WS " "
        \    LBRACE "{"
        \    RBRACE "}"
        \    WS "\n"
        \  STRUKT
        \    STRUCTKW "struct"
        \    WS " "
        \    IDENT "b"
        \    WS " "
        \    LBRACE "{"
        \    WS " "
        \    FIELD
        \      IDENT "foo"
        \      WS " "
        \      TYPE
        \        IDENT "bar"
        \        WS " "
        \    RBRACE "}"
        \    WS "\n"
        \  STRUKT
        \    STRUCTKW "struct"
        \    WS " "
        \    IDENT "c"
        \    WS " "
        \    LBRACE "{"
        \    WS " "
        \    FIELD
        \      IDENT "foo"
        \      WS " "
        \      TYPE
        \        IDENT "bar"
        \    COMMA ","
        \    WS " "
        \    FIELD
        \      IDENT "baz"
        \      WS " "
        \      TYPE
        \        IDENT "quux"
        \        WS " "
        \    RBRACE "}"
        \    WS "\n"
        \  STRUKT
        \    STRUCTKW "struct"
        \    WS " "
        \    IDENT "person"
        \    WS " "
        \    LBRACE "{"
        \    WS "\n    "
        \    FIELD
        \      IDENT "name"
        \      WS " "
        \      TYPE
        \        STAR "*"
        \        TYPE
        \          IDENT "char"
        \    COMMA ","
        \    WS "\n    "
        \    FIELD
        \      IDENT "age"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    COMMA ","
        \    WS "\n"
        \    RBRACE "}"
    );
}

fn test_parser_constants() {
    parsertestharness(
        \let PI = 3;
        \let G = 10;
        ,
        \ROOT
        \  CONSTANT
        \    LETKW "let"
        \    WS " "
        \    IDENT "PI"
        \    WS " "
        \    EQUAL "="
        \    WS " "
        \    NUMBER "3"
        \    SEMI ";"
        \    WS "\n"
        \  CONSTANT
        \    LETKW "let"
        \    WS " "
        \    IDENT "G"
        \    WS " "
        \    EQUAL "="
        \    WS " "
        \    NUMBER "10"
        \    SEMI ";"
    );
}

fn test_parser_returnstatements() {
    parsertestharness(
        \fn f() {
        \    return;
        \    return 10;
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "f"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      RETURNSTMT
        \        RETURNKW "return"
        \        SEMI ";"
        \        WS "\n    "
        \      RETURNSTMT
        \        RETURNKW "return"
        \        WS " "
        \        NUMBER "10"
        \        SEMI ";"
        \        WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_breakstatement() {
    parsertestharness(
        \fn main() { break; }
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS " "
        \      BREAKSTMT
        \        BREAKKW "break"
        \        SEMI ";"
        \        WS " "
        \      RBRACE "}"
    );
}

fn test_parser_forloops() {
    parsertestharness(
        \fn main() {
        \    for {}
        \    for { a; b; c; break; }
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      FORSTMT
        \        FORKW "for"
        \        WS " "
        \        BLOCK
        \          LBRACE "{"
        \          RBRACE "}"
        \          WS "\n    "
        \      FORSTMT
        \        FORKW "for"
        \        WS " "
        \        BLOCK
        \          LBRACE "{"
        \          WS " "
        \          EXPRSTMT
        \            VARIABLE
        \              IDENT "a"
        \            SEMI ";"
        \            WS " "
        \          EXPRSTMT
        \            VARIABLE
        \              IDENT "b"
        \            SEMI ";"
        \            WS " "
        \          EXPRSTMT
        \            VARIABLE
        \              IDENT "c"
        \            SEMI ";"
        \            WS " "
        \          BREAKSTMT
        \            BREAKKW "break"
        \            SEMI ";"
        \            WS " "
        \          RBRACE "}"
        \          WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_ifstatements() {
    parsertestharness(
        \fn main() {
        \    if true { a; b; }
        \    if false { truebranch(); } else { falsebranch(); }
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      IFSTMT
        \        IFKW "if"
        \        WS " "
        \        VARIABLE
        \          IDENT "true"
        \          WS " "
        \        BLOCK
        \          LBRACE "{"
        \          WS " "
        \          EXPRSTMT
        \            VARIABLE
        \              IDENT "a"
        \            SEMI ";"
        \            WS " "
        \          EXPRSTMT
        \            VARIABLE
        \              IDENT "b"
        \            SEMI ";"
        \            WS " "
        \          RBRACE "}"
        \          WS "\n    "
        \      IFSTMT
        \        IFKW "if"
        \        WS " "
        \        VARIABLE
        \          IDENT "false"
        \          WS " "
        \        BLOCK
        \          LBRACE "{"
        \          WS " "
        \          EXPRSTMT
        \            CALL
        \              IDENT "truebranch"
        \              LPAREN "("
        \              RPAREN ")"
        \            SEMI ";"
        \            WS " "
        \          RBRACE "}"
        \          WS " "
        \        ELSEKW "else"
        \        WS " "
        \        BLOCK
        \          LBRACE "{"
        \          WS " "
        \          EXPRSTMT
        \            CALL
        \              IDENT "falsebranch"
        \              LPAREN "("
        \              RPAREN ")"
        \            SEMI ";"
        \            WS " "
        \          RBRACE "}"
        \          WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_simplearithmetic() {
    parsertestharness(
        \fn main() {
        \    1 + 2 - 3 * 4 / -5;
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      EXPRSTMT
        \        BINARYEXPR
        \          BINARYEXPR
        \            NUMBER "1"
        \            WS " "
        \            PLUS "+"
        \            WS " "
        \            NUMBER "2"
        \            WS " "
        \          HYPHEN "-"
        \          WS " "
        \          BINARYEXPR
        \            BINARYEXPR
        \              NUMBER "3"
        \              WS " "
        \              STAR "*"
        \              WS " "
        \              NUMBER "4"
        \              WS " "
        \            SLASH "/"
        \            WS " "
        \            PREFIXEXPR
        \              HYPHEN "-"
        \              NUMBER "5"
        \        SEMI ";"
        \        WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_booleanoperators() {
    parsertestharness(
        \fn main() {
        \    a < b &&
        \    a <= b &&
        \    a > b &&
        \    a >= b &&
        \    a == b &&
        \    a != b ||
        \    !false ||
        \    !(dothing() + 1);
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      EXPRSTMT
        \        BINARYEXPR
        \          BINARYEXPR
        \            BINARYEXPR
        \              BINARYEXPR
        \                BINARYEXPR
        \                  BINARYEXPR
        \                    BINARYEXPR
        \                      BINARYEXPR
        \                        VARIABLE
        \                          IDENT "a"
        \                          WS " "
        \                        LT "<"
        \                        WS " "
        \                        VARIABLE
        \                          IDENT "b"
        \                          WS " "
        \                      PRETZEL "&"
        \                      PRETZEL "&"
        \                      WS "\n    "
        \                      BINARYEXPR
        \                        VARIABLE
        \                          IDENT "a"
        \                          WS " "
        \                        LT "<"
        \                        EQUAL "="
        \                        WS " "
        \                        VARIABLE
        \                          IDENT "b"
        \                          WS " "
        \                    PRETZEL "&"
        \                    PRETZEL "&"
        \                    WS "\n    "
        \                    BINARYEXPR
        \                      VARIABLE
        \                        IDENT "a"
        \                        WS " "
        \                      GT ">"
        \                      WS " "
        \                      VARIABLE
        \                        IDENT "b"
        \                        WS " "
        \                  PRETZEL "&"
        \                  PRETZEL "&"
        \                  WS "\n    "
        \                  BINARYEXPR
        \                    VARIABLE
        \                      IDENT "a"
        \                      WS " "
        \                    GT ">"
        \                    EQUAL "="
        \                    WS " "
        \                    VARIABLE
        \                      IDENT "b"
        \                      WS " "
        \                PRETZEL "&"
        \                PRETZEL "&"
        \                WS "\n    "
        \                BINARYEXPR
        \                  VARIABLE
        \                    IDENT "a"
        \                    WS " "
        \                  EQUAL "="
        \                  EQUAL "="
        \                  WS " "
        \                  VARIABLE
        \                    IDENT "b"
        \                    WS " "
        \              PRETZEL "&"
        \              PRETZEL "&"
        \              WS "\n    "
        \              BINARYEXPR
        \                VARIABLE
        \                  IDENT "a"
        \                  WS " "
        \                BANG "!"
        \                EQUAL "="
        \                WS " "
        \                VARIABLE
        \                  IDENT "b"
        \                  WS " "
        \            PIPE "|"
        \            PIPE "|"
        \            WS "\n    "
        \            PREFIXEXPR
        \              BANG "!"
        \              VARIABLE
        \                IDENT "false"
        \                WS " "
        \          PIPE "|"
        \          PIPE "|"
        \          WS "\n    "
        \          PREFIXEXPR
        \            BANG "!"
        \            PARENEXPR
        \              LPAREN "("
        \              BINARYEXPR
        \                CALL
        \                  IDENT "dothing"
        \                  LPAREN "("
        \                  RPAREN ")"
        \                  WS " "
        \                PLUS "+"
        \                WS " "
        \                NUMBER "1"
        \              RPAREN ")"
        \        SEMI ";"
        \        WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_pointeroperators() {
    parsertestharness(
        \fn main() {
        \    *ptr + 1;
        \    *(ptr + 1);
        \    &foo;
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      EXPRSTMT
        \        BINARYEXPR
        \          PREFIXEXPR
        \            STAR "*"
        \            VARIABLE
        \              IDENT "ptr"
        \              WS " "
        \          PLUS "+"
        \          WS " "
        \          NUMBER "1"
        \        SEMI ";"
        \        WS "\n    "
        \      EXPRSTMT
        \        PREFIXEXPR
        \          STAR "*"
        \          PARENEXPR
        \            LPAREN "("
        \            BINARYEXPR
        \              VARIABLE
        \                IDENT "ptr"
        \                WS " "
        \              PLUS "+"
        \              WS " "
        \              NUMBER "1"
        \            RPAREN ")"
        \        SEMI ";"
        \        WS "\n    "
        \      EXPRSTMT
        \        PREFIXEXPR
        \          PRETZEL "&"
        \          VARIABLE
        \            IDENT "foo"
        \        SEMI ";"
        \        WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_fieldoperators() {
    parsertestharness(
        \fn main() {
        \    *(a.b->c + 1).foo.bar;
        \}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "main"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    BLOCK
        \      LBRACE "{"
        \      WS "\n    "
        \      EXPRSTMT
        \        PREFIXEXPR
        \          STAR "*"
        \          FIELDEXPR
        \            FIELDEXPR
        \              PARENEXPR
        \                LPAREN "("
        \                BINARYEXPR
        \                  FIELDEXPR
        \                    FIELDEXPR
        \                      VARIABLE
        \                        IDENT "a"
        \                      DOT "."
        \                      IDENT "b"
        \                    HYPHEN "-"
        \                    GT ">"
        \                    IDENT "c"
        \                    WS " "
        \                  PLUS "+"
        \                  WS " "
        \                  NUMBER "1"
        \                RPAREN ")"
        \              DOT "."
        \              IDENT "foo"
        \            DOT "."
        \            IDENT "bar"
        \        SEMI ";"
        \        WS "\n"
        \      RBRACE "}"
    );
}

fn test_parser_externitems() {
    parsertestharness(
        \extern struct FILE;
        \extern fn malloc;
        ,
        \ROOT
        \  XTERN
        \    EXTERNKW "extern"
        \    WS " "
        \    STRUCTKW "struct"
        \    WS " "
        \    IDENT "FILE"
        \    SEMI ";"
        \    WS "\n"
        \  XTERN
        \    EXTERNKW "extern"
        \    WS " "
        \    FNKW "fn"
        \    WS " "
        \    IDENT "malloc"
        \    SEMI ";"
    );
}

fn parsertestharness(text *char, expected *char) {
    let result parseresult = parse(str_new(text));
    let actual str = syntaxtree_format(result.tree, text);

    let i int = 0;
    for {
        if i == result.errorslen { break; }
        let error syntaxerror = *(result.errorsptr + i);

        let len int = sprintf(
            actual.ptr + actual.len,
            "\nerror at %d..%d: ",
            error.range.start,
            error.range.start + error.range.len,
        );
        actual.len += len;

        memcpy(actual.ptr + actual.len, error.message.ptr, error.message.len);
        actual.len += error.message.len;

        i += 1;
    }

    if !str_prettyequal(actual, expected) { exit(1); }
}

struct type { name range, pointsto *type }
struct param { name range, type type }
struct function {
    name range,
    paramsptr *param,
    paramslen int,
    paramscap int,
    returntype *type,
}
struct field { name range, type type }
struct strukt {
    name range,
    fieldsptr *field,
    fieldslen int,
    fieldscap int,
}
struct constant { name range }
struct item {
    kind char,
    function function,
    strukt strukt,
    constant constant,
}
let ITEM_FUNCTION = 1;
let ITEM_STRUKT = 2;
let ITEM_CONSTANT = 3;
struct fileindex { itemsptr *item, itemslen int, itemscap int }

fn fileindex_new(tree syntaxtree) fileindex {
    let i fileindex;
    i.itemsptr = malloc(8 * sizeof(item));
    i.itemslen = 0;
    i.itemscap = 8;

    let child *syntaxchild = tree.root->child;
    for {
        if child == 0 { break; }

        let item item;

        if child->kind == SK_FUNCTION {
            item.kind = ITEM_FUNCTION;
            item.function = lowerfunction(child);
        }

        if child->kind == SK_STRUKT {
            item.kind = ITEM_STRUKT;
            item.strukt = lowerstrukt(child);
        }

        if child->kind == SK_CONSTANT {
            item.kind = ITEM_CONSTANT;
            item.constant = lowerconstant(child);
        }

        if i.itemslen == i.itemscap {
            i.itemscap *= 2;
            i.itemsptr = realloc(i.itemsptr, i.itemscap);
        }

        *(i.itemsptr + i.itemslen) = item;
        i.itemslen += 1;

        child = child->next;
    }

    return i;
}

fn lowerfunction(child *syntaxchild) function {
    let f function;
    f.name = syntaxchild_findchild(child, SK_IDENT)->range;
    f.paramsptr = malloc(4 * sizeof(param));
    f.paramslen = 0;
    f.paramscap = 4;

    let c *syntaxchild = child->child;
    for {
        if c == 0 { break; }
        if c->kind == SK_PARAM {
            if f.paramscap == f.paramslen {
                f.paramscap *= 2;
                f.paramsptr = realloc(f.paramsptr, f.paramscap);
            }
            (f.paramsptr + f.paramslen)->name =
                syntaxchild_findchild(c, SK_IDENT)->range;
            (f.paramsptr + f.paramslen)->type =
                lowertype(syntaxchild_findchild(c, SK_TYPE));
            f.paramslen += 1;
        }
        c = c->next;
    }

    let returntype *syntaxchild = syntaxchild_findchild(child, SK_TYPE);
    if returntype == 0 {
        f.returntype = 0;
    } else {
        f.returntype = malloc(sizeof(type));
        *f.returntype = lowertype(returntype);
    }

    return f;
}

fn lowerstrukt(child *syntaxchild) strukt {
    let s strukt;
    s.name = syntaxchild_findchild(child, SK_IDENT)->range;
    s.fieldsptr = malloc(4 * sizeof(field));
    s.fieldslen = 0;
    s.fieldscap = 4;

    let c *syntaxchild = child->child;
    for {
        if c == 0 { break; }
        if c->kind == SK_FIELD {
            if s.fieldscap == s.fieldslen {
                s.fieldscap *= 2;
                s.fieldsptr = realloc(s.fieldsptr, s.fieldscap);
            }
            (s.fieldsptr + s.fieldslen)->name =
                syntaxchild_findchild(c, SK_IDENT)->range;
            (s.fieldsptr + s.fieldslen)->type =
                lowertype(syntaxchild_findchild(c, SK_TYPE));
            s.fieldslen += 1;
        }
        c = c->next;
    }

    return s;
}

fn lowerconstant(child *syntaxchild) constant {
    let c constant;
    c.name = syntaxchild_findchild(child, SK_IDENT)->range;
    return c;
}

fn lowertype(c *syntaxchild) type {
    let t type;
    let name *syntaxchild = syntaxchild_findchild(c, SK_IDENT);
    if name == 0 {
        t.pointsto = malloc(sizeof(type));
        *t.pointsto = lowertype(syntaxchild_findchild(c, SK_TYPE));
    } else {
        t.name = name->range;
        t.pointsto = 0;
    }
    return t;
}

fn fileindex_format(index fileindex, text *char) str {
    let s str;
    s.ptr = malloc(1024);
    s.len = 0;

    let i int = 0;
    for {
        if i == index.itemslen { break; }

        if i != 0 {
            *(s.ptr + s.len) = '\n';
            s.len += 1;
        }

        let item item = *(index.itemsptr + i);

        if item.kind == ITEM_FUNCTION {
            memcpy(s.ptr + s.len, "fn ", 3);
            s.len += 3;

            memcpy(
                s.ptr + s.len,
                text + item.function.name.start,
                item.function.name.len,
            );
            s.len += item.function.name.len;

            memcpy(s.ptr + s.len, "(", 1);
            s.len += 1;

            let paramidx int = 0;
            for {
                if paramidx == item.function.paramslen { break; }

                if paramidx != 0 {
                    memcpy(s.ptr + s.len, ", ", 2);
                    s.len += 2;
                }

                let p param = *(item.function.paramsptr + paramidx);

                memcpy(s.ptr + s.len, text + p.name.start, p.name.len);
                s.len += p.name.len;

                memcpy(s.ptr + s.len, " ", 1);
                s.len += 1;

                memcpy(s.ptr + s.len, text + p.type.name.start, p.type.name.len);
                s.len += p.type.name.len;

                paramidx += 1;
            }

            memcpy(s.ptr + s.len, ") ", 2);
            s.len += 2;

            if item.function.returntype != 0 {
                type_format(*item.function.returntype, text, &s);
                memcpy(s.ptr + s.len, " ", 1);
                s.len += 1;
            }

            memcpy(s.ptr + s.len, "{}", 2);
            s.len += 2;
        }

        if item.kind == ITEM_STRUKT {
            memcpy(s.ptr + s.len, "struct ", 7);
            s.len += 7;

            memcpy(
                s.ptr + s.len,
                text + item.strukt.name.start,
                item.strukt.name.len,
            );
            s.len += item.strukt.name.len;

            memcpy(s.ptr + s.len, " {", 2);
            s.len += 2;

            let fieldidx int = 0;
            for {
                if fieldidx == item.strukt.fieldslen { break; }
                let f field = *(item.strukt.fieldsptr + fieldidx);

                if fieldidx == 0 {
                    memcpy(s.ptr + s.len, "\n", 1);
                    s.len += 1;
                }

                memcpy(s.ptr + s.len, "    ", 4);
                s.len += 4;

                memcpy(s.ptr + s.len, text + f.name.start, f.name.len);
                s.len += f.name.len;

                memcpy(s.ptr + s.len, " ", 1);
                s.len += 1;

                type_format(f.type, text, &s);

                memcpy(s.ptr + s.len, ",\n", 2);
                s.len += 2;

                fieldidx += 1;
            }

            memcpy(s.ptr + s.len, "}", 1);
            s.len += 1;
        }

        if item.kind == ITEM_CONSTANT {
            memcpy(s.ptr + s.len, "let ", 4);
            s.len += 4;

            memcpy(
                s.ptr + s.len,
                text + item.constant.name.start,
                item.constant.name.len,
            );
            s.len += item.constant.name.len;

            memcpy(s.ptr + s.len, ";", 1);
            s.len += 1;
        }

        i += 1;
    }

    return s;
}

fn type_format(type type, text *char, s *str) {
    if type.pointsto == 0 {
        memcpy(s->ptr + s->len, text + type.name.start, type.name.len);
        s->len += type.name.len;
    } else {
        *(s->ptr + s->len) = '*';
        s->len += 1;
        type_format(*type.pointsto, text, s);
    }
}

fn test_indexing() {
    printf("    test empty\n"); test_indexing_empty();
    printf("    test simplefunction\n"); test_indexing_simplefunction();
    printf("    test functions\n"); test_indexing_functions();
    printf("    test functionwithreturntype\n"); test_indexing_functionwithreturntype();
    printf("    test functionwithparameters\n"); test_indexing_functionwithparameters();
    printf("    test emptystruct\n"); test_indexing_emptystruct();
    printf("    test structwithfields\n"); test_indexing_structwithfields();
    printf("    test constants\n"); test_indexing_constants();
}

fn test_indexing_empty() {
    indexingtestharness("", "");
}

fn test_indexing_simplefunction() {
    indexingtestharness(
        \fn a() {}
        ,
        \fn a() {}
    );
}

fn test_indexing_functions() {
    indexingtestharness(
        \fn x() {}
        \fn y() {}
        ,
        \fn x() {}
        \fn y() {}
    );
}

fn test_indexing_functionwithreturntype() {
    indexingtestharness(
        \fn f() int {}
        ,
        \fn f() int {}
    );
}

fn test_indexing_functionwithparameters() {
    indexingtestharness(
        \fn add(x int, y int) int {}
        ,
        \fn add(x int, y int) int {}
    );
}

fn test_indexing_emptystruct() {
    indexingtestharness(
        \struct foo {}
        ,
        \struct foo {}
    );
}

fn test_indexing_structwithfields() {
    indexingtestharness(
        \struct person {
        \    name *char,
        \    namelen int,
        \    age int,
        \}
        ,
        \struct person {
        \    name *char,
        \    namelen int,
        \    age int,
        \}
    );
}

fn test_indexing_constants() {
    indexingtestharness(
        \let FOO = 1;
        \let BAR = 2;
        ,
        \let FOO;
        \let BAR;
    );
}

fn indexingtestharness(text *char, expected *char) {
    let r parseresult = parse(str_new(text));
    let i fileindex = fileindex_new(r.tree);
    let actual str = fileindex_format(i, text);

    if !str_prettyequal(actual, expected) { exit(1); }
}
