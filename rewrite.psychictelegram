fn main() int {
    tests();
}

struct str { data *char, len int }
struct range { start int, len int }

fn range_equal(r range, start int, len int) bool {
    return r.start == start && r.len == len;
}

fn str_print(s str) {
    let i int = 0;
    for {
        if i == s.len { break; }
        printf("%c", *(s.data + i));
        i += 1;
    }
}

fn tests() {
    printf("--> SYNTAX\n"); test_syntax();
}

struct syntaxchild {
    istoken bool,
    kind char,
    range range,
    next *syntaxchild,
    child *syntaxchild,
    parent *syntaxchild,
}

struct syntaxtree { root *syntaxchild }

struct syntaxbuilder {
    root *syntaxchild,
    current *syntaxchild,
    inputidx int,
}

fn syntaxbuilder_new() syntaxbuilder {
    let b syntaxbuilder;
    b.root = 0;
    b.current = 0;
    b.inputidx = 0;
    return b;
}

fn syntaxbuilder_startnode(b *syntaxbuilder, kind char) {
    let new syntaxchild;
    new.istoken = false;
    new.kind = kind;
    new.range.start = b->inputidx;
    new.range.len = 0;
    new.next = 0;
    new.child = 0;
    new.parent = b->current;

    let newallocated *syntaxchild = malloc(sizeof(syntaxchild));
    *newallocated = new;

    if b->current == 0 {
        b->current = newallocated;
        b->root = newallocated;
    } else {
        syntaxchild_addchild(b->current, newallocated);
        b->current = newallocated;
    }
}

fn syntaxbuilder_addtoken(b *syntaxbuilder, kind char, len int) {
    let child *syntaxchild = malloc(sizeof(syntaxchild));
    child->istoken = true;
    child->kind = kind;
    child->range.start = b->inputidx;
    child->range.len = len;
    child->next = 0;
    child->child = 0;
    child->parent = b->current;
    syntaxchild_addchild(b->current, child);
    b->inputidx += len;
}

fn syntaxbuilder_finishnode(b *syntaxbuilder) {
    b->current->range.len = b->inputidx - b->current->range.start;
    b->current = b->current->parent;
}

fn syntaxbuilder_finish(b syntaxbuilder) syntaxtree {
    let t syntaxtree;
    t.root = b.root;
    return t;
}

fn syntaxchild_addchild(c *syntaxchild, newchild *syntaxchild) {
    let placetoinsert **syntaxchild = &c->child;
    for {
        if *placetoinsert == 0 { break; }
        let c *syntaxchild = *placetoinsert;
        placetoinsert = &c->next;
    }
    *placetoinsert = newchild;
}

fn syntaxtree_print(t syntaxtree, text *char) {
    let indentation int = 0;
    let current syntaxchild = *t.root;

    for {
        let i int = 0;
        for {
            if i == indentation { break; }
            printf("\x1B[90mâ”‚\x1B[0m ");
            i += 1;
        }

        printf("\x1B[94m");
        syntaxkind_print(current.kind);
        printf(
            " \x1B[92m%d\x1B[0m..\x1B[92m%d",
            current.range.start,
            current.range.start + current.range.len,
        );

        if current.istoken {
            printf(" \x1B[35m\"");
            let s str;
            s.data = text + current.range.start;
            s.len = current.range.len;
            printf("\x1B[95m");
            str_print(s);
            printf("\x1B[35m\"");
        }

        printf("\x1B[0m\n");

        if current.child == 0 {
            let c syntaxchild = current;
            for {
                if c.next != 0 { break; }
                if c.parent == 0 { return; }
                c = *c.parent;
                indentation -= 1;
            }
            current = *c.next;
        } else {
            current = *current.child;
            indentation += 1;
        }
    }
}

fn syntaxkind_print(kind char) {
    if kind == 1 { printf("root"); }
    if kind == 2 { printf("function"); }
    if kind == 3 { printf("fnkw"); }
    if kind == 4 { printf("ident"); }
}

fn test_syntax() {
    printf("    test empty\n"); test_syntax_empty();
    printf("    test addtoken\n"); test_syntax_addtoken();
    printf("    test root\n"); test_syntax_root();
    printf("    test links\n"); test_syntax_links();
}

fn test_syntax_empty() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, 0);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finish(b);
}

fn test_syntax_addtoken() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, 0);
    syntaxbuilder_addtoken(&b, 0, 3);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finish(b);
}

fn test_syntax_root() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, 2);
    syntaxbuilder_addtoken(&b, 0, 1);
    syntaxbuilder_addtoken(&b, 0, 1);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);
    let root syntaxchild = *t.root;
    assert(range_equal(root.range, 0, 2));
    assert(root.kind == 2);
}

fn test_syntax_links() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, 1);
    syntaxbuilder_startnode(&b, 2);
    syntaxbuilder_addtoken(&b, 3, 2);
    syntaxbuilder_addtoken(&b, 4, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_startnode(&b, 2);
    syntaxbuilder_addtoken(&b, 3, 2);
    syntaxbuilder_addtoken(&b, 4, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);
    let root syntaxchild = *t.root;

    let node1 syntaxchild = *root.child;
    assert(node1.kind == 2);
    assert(range_equal(node1.range, 0, 3));

    let node1child1 syntaxchild = *node1.child;
    assert(node1child1.kind == 3);
    assert(range_equal(node1child1.range, 0, 2));

    let node1child2 syntaxchild = *node1child1.next;
    assert(node1child2.kind == 4);
    assert(range_equal(node1child2.range, 2, 1));

    assert(node1child2.next == 0);

    let node2 syntaxchild = *node1.next;
    assert(node1.kind == 2);
    assert(range_equal(node2.range, 3, 3));

    let node2child1 syntaxchild = *node2.child;
    assert(node1child1.kind == 3);
    assert(range_equal(node2child1.range, 3, 2));

    let node2child2 syntaxchild = *node2child1.next;
    assert(node1child2.kind == 4);
    assert(range_equal(node2child2.range, 5, 1));

    assert(node2child2.next == 0);

    assert(node2.next == 0);
}
