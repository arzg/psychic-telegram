fn main() int {
    tests();
}

struct str { ptr *char, len int }
struct range { start int, len int }

fn str_new(nullterminated *char) str {
    let lenprefixed str;
    lenprefixed.ptr = nullterminated;
    lenprefixed.len = strlen(nullterminated);
    return lenprefixed;
}

fn str_empty() str {
    let s str;
    s.ptr = 0;
    s.len = 0;
    return s;
}

fn str_equal(s1 str, nullterminated *char) bool {
    return str_equalstr(s1, str_new(nullterminated));
}

fn str_equalstr(s1 str, s2 str) bool {
    if s1.len != s2.len { return false; }
    let i int = 0;
    for {
        if i > s1.len { break; }
        let c1 char = *(s1.ptr + i);
        let c2 char = *(s2.ptr + i);
        if c1 != c2 { return false; }
        i += 1;
    }
    return true;
}

fn str_prettyequal(actual str, expectednullterminated *char) bool {
    let expected str = str_new(expectednullterminated);

    if str_equalstr(actual, expected) { return true; }

    printf("\x1B[91mstrings not equal!\x1B[0m");

    printf("\n");
    printf("\nactual");
    printf("\n──────");
    printf("\n\x1B[94m");
    str_print(actual);
    printf("\x1B[0m");
    printf("\n──────");

    printf("\n");
    printf("\nexpected");
    printf("\n──────");
    printf("\n\x1B[95m");
    str_print(expected);
    printf("\x1B[0m");
    printf("\n──────");

    printf("\n");
    printf("\ndiff");
    printf("\n──────");
    for {
        if actual.len == 0 && expected.len == 0 { break; }
        if actual.len == 0 {
            let line str = str_eatline(&expected);
            printf("\n\x1B[95m");
            str_print(line);
            printf("\x1B[0m");
        } else {
            if expected.len == 0 {
                let line str = str_eatline(&actual);
                printf("\n\x1B[94m");
                str_print(line);
                printf("\x1B[0m");
            } else {
                let actualline str = str_eatline(&actual);
                let expectedline str = str_eatline(&expected);
                if str_equalstr(actualline, expectedline) {
                    printf("\n");
                    str_print(actualline);
                } else {
                    printf("\n\x1B[94m");
                    str_print(actualline);
                    printf("\n\x1B[95m");
                    str_print(expectedline);
                    printf("\x1B[0m");
                }
            }
        }
    }

    printf("\n");
    printf("──────\n");

    return false;
}

fn str_eatline(s *str) str {
    let newlineidx int = 0;
    let reachedend bool = false;
    for {
        if newlineidx == s->len {
            reachedend = true;
            break;
        }
        newlineidx += 1;
        if *(s->ptr + newlineidx - 1) == '\n' { break; }
    }

    let line str;
    line.ptr = s->ptr;
    line.len = newlineidx;
    if !reachedend { line.len -= 1; }
    s->ptr += newlineidx;
    s->len -= newlineidx;

    return line;
}

fn str_print(s str) {
    let i int = 0;
    for {
        if i == s.len { break; }
        printf("%c", *(s.ptr + i));
        i += 1;
    }
}

fn range_equal(r range, start int, len int) bool {
    return r.start == start && r.len == len;
}

fn range_print(r range) {
    printf("\x1B[92m%d\x1B[0m..\x1B[92m%d\x1B[0m", r.start, r.start + r.len);
}

fn tests() {
    printf("--> LEXER\n"); test_lexer();
    printf("--> SYNTAX\n"); test_syntax();
    printf("--> PARSER\n"); test_parser();
    printf("--> INDEXING\n"); test_indexing();
}

struct lexer { text str, range range }
struct token { kind char, range range }
struct tokens { ptr *token, len int }

let SK_EOF = 0;
let SK_ERROR = 1;
let SK_WS = 2;
let SK_NUMBER = 3;
let SK_IDENT = 4;
let SK_STRING = 5;
let SK_RAWSTRING = 6;
let SK_CHAR = 7;
let SK_DOT = 8;
let SK_COLON = 9;
let SK_COMMA = 10;
let SK_SEMI = 11;
let SK_LPAREN = 12;
let SK_RPAREN = 13;
let SK_LBRACE = 14;
let SK_RBRACE = 15;
let SK_PLUS = 16;
let SK_HYPEN = 17;
let SK_STAR = 18;
let SK_SLASH = 19;
let SK_EQUAL = 20;
let SK_BANG = 21;
let SK_PRETZEL = 22;
let SK_PIPE = 23;
let SK_LT = 24;
let SK_GT = 25;
let SK_FNKW = 26;
let SK_STRUCTKW = 27;
let SK_LETKW = 28;
let SK_IFKW = 29;
let SK_FORKW = 30;
let SK_BREAKKW = 31;
let SK_RETURNKW = 32;
let SK_COMMENT = 33;

let SK_ROOT = -1;
let SK_FUNCTION = -2;
let SK_TYPE = -3;
let SK_PARAM = -4;

fn syntaxkind_print(k char) {
    printf("\x1B[94m");
    str_print(syntaxkind_format(k));
    printf("\x1B[0m");
}

fn syntaxkind_format(k char) str {
    if k == 0 { return str_new("EOF"); }
    if k == 1 { return str_new("ERROR"); }
    if k == 2 { return str_new("WS"); }
    if k == 3 { return str_new("NUMBER"); }
    if k == 4 { return str_new("IDENT"); }
    if k == 5 { return str_new("STRING"); }
    if k == 6 { return str_new("RAWSTRING"); }
    if k == 7 { return str_new("CHAR"); }
    if k == 8 { return str_new("DOT"); }
    if k == 9 { return str_new("COLON"); }
    if k == 10 { return str_new("COMMA"); }
    if k == 11 { return str_new("SEMI"); }
    if k == 12 { return str_new("LPAREN"); }
    if k == 13 { return str_new("RPAREN"); }
    if k == 14 { return str_new("LBRACE"); }
    if k == 15 { return str_new("RBRACE"); }
    if k == 16 { return str_new("PLUS"); }
    if k == 17 { return str_new("HYPEN"); }
    if k == 18 { return str_new("STAR"); }
    if k == 19 { return str_new("SLASH"); }
    if k == 20 { return str_new("EQUAL"); }
    if k == 21 { return str_new("BANG"); }
    if k == 22 { return str_new("PRETZEL"); }
    if k == 23 { return str_new("PIPE"); }
    if k == 24 { return str_new("LT"); }
    if k == 25 { return str_new("GT"); }
    if k == 26 { return str_new("FNKW"); }
    if k == 27 { return str_new("STRUCTKW"); }
    if k == 28 { return str_new("LETKW"); }
    if k == 29 { return str_new("IFKW"); }
    if k == 30 { return str_new("FORKW"); }
    if k == 31 { return str_new("BREAKKW"); }
    if k == 32 { return str_new("RETURNKW"); }
    if k == 33 { return str_new("COMMENT"); }
    if k == -1 { return str_new("ROOT"); }
    if k == -2 { return str_new("FUNCTION"); }
    if k == -3 { return str_new("TYPE"); }
    if k == -4 { return str_new("PARAM"); }

    printf("bad syntaxkind\n");
    exit(1);
}

fn lex(text str) tokens {
    let cap int = 8;
    let tokens tokens;
    tokens.ptr = malloc(cap * sizeof(token));
    tokens.len = 0;

    let l lexer = lexer_new(text);

    for {
        let t token = lexer_next(&l);
        if t.kind == SK_EOF { break; }

        if tokens.len == cap {
            cap *= 2;
            tokens.ptr = realloc(tokens.ptr, cap * sizeof(token));
        }
        *(tokens.ptr + tokens.len) = t;
        tokens.len += 1;
    }

    return tokens;
}

fn lexer_new(text str) lexer {
    let l lexer;
    l.text = text;
    l.range.start = 0;
    l.range.len = 0;
    return l;
}

fn lexer_next(l *lexer) token {
    if lexer_ateof(l) {
        let t token;
        t.kind = SK_EOF;
        t.range.start = 0;
        t.range.len = 0;
        return t;
    }

    if lexer_atws(l) { return lexer_ws(l); }
    if lexer_atdigit(l) { return lexer_number(l); }
    if lexer_atalpha(l) { return lexer_ident(l); }
    if lexer_current(l) == '"' { return lexer_delimited(l, '"', SK_STRING); }
    if lexer_current(l) == 39 { return lexer_delimited(l, 39, SK_CHAR); }
    if lexer_current(l) == '\\' { return lexer_rawstring(l); }
    if lexer_current(l) == '#' { return lexer_comment(l); }

    if lexer_current(l) == '.' {
        l->range.len += 1;
        return lexer_emit(l, SK_DOT);
    }
    if lexer_current(l) == ':' {
        l->range.len += 1;
        return lexer_emit(l, SK_COLON);
    }
    if lexer_current(l) == ',' {
        l->range.len += 1;
        return lexer_emit(l, SK_COMMA);
    }
    if lexer_current(l) == ';' {
        l->range.len += 1;
        return lexer_emit(l, SK_SEMI);
    }
    if lexer_current(l) == '(' {
        l->range.len += 1;
        return lexer_emit(l, SK_LPAREN);
    }
    if lexer_current(l) == ')' {
        l->range.len += 1;
        return lexer_emit(l, SK_RPAREN);
    }
    if lexer_current(l) == '{' {
        l->range.len += 1;
        return lexer_emit(l, SK_LBRACE);
    }
    if lexer_current(l) == '}' {
        l->range.len += 1;
        return lexer_emit(l, SK_RBRACE);
    }
    if lexer_current(l) == '+' {
        l->range.len += 1;
        return lexer_emit(l, SK_PLUS);
    }
    if lexer_current(l) == '-' {
        l->range.len += 1;
        return lexer_emit(l, SK_HYPEN);
    }
    if lexer_current(l) == '*' {
        l->range.len += 1;
        return lexer_emit(l, SK_STAR);
    }
    if lexer_current(l) == '/' {
        l->range.len += 1;
        return lexer_emit(l, SK_SLASH);
    }
    if lexer_current(l) == '=' {
        l->range.len += 1;
        return lexer_emit(l, SK_EQUAL);
    }
    if lexer_current(l) == '!' {
        l->range.len += 1;
        return lexer_emit(l, SK_BANG);
    }
    if lexer_current(l) == '&' {
        l->range.len += 1;
        return lexer_emit(l, SK_PRETZEL);
    }
    if lexer_current(l) == '|' {
        l->range.len += 1;
        return lexer_emit(l, SK_PIPE);
    }
    if lexer_current(l) == '<' {
        l->range.len += 1;
        return lexer_emit(l, SK_LT);
    }
    if lexer_current(l) == '>' {
        l->range.len += 1;
        return lexer_emit(l, SK_GT);
    }

    l->range.len += 1;
    return lexer_emit(l, SK_ERROR);
}

fn lexer_ws(l *lexer) token {
    for {
        if lexer_ateof(l) || !lexer_atws(l) { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_WS);
}

fn lexer_number(l *lexer) token {
    for {
        if lexer_ateof(l) || !lexer_atdigit(l) { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_NUMBER);
}

fn lexer_ident(l *lexer) token {
    for {
        if lexer_ateof(l) ||
            !(
                lexer_atalpha(l) ||
                lexer_atdigit(l) ||
                lexer_current(l) == '_'
            ) { break; }
        l->range.len += 1;
    }

    let text str = lexer_text(l);
    if str_equal(text, "fn") { return lexer_emit(l, SK_FNKW); }
    if str_equal(text, "struct") { return lexer_emit(l, SK_STRUCTKW); }
    if str_equal(text, "let") { return lexer_emit(l, SK_LETKW); }
    if str_equal(text, "if") { return lexer_emit(l, SK_IFKW); }
    if str_equal(text, "for") { return lexer_emit(l, SK_FORKW); }
    if str_equal(text, "break") { return lexer_emit(l, SK_BREAKKW); }
    if str_equal(text, "return") { return lexer_emit(l, SK_RETURNKW); }

    return lexer_emit(l, SK_IDENT);
}

fn lexer_delimited(l *lexer, delimiter char, kind char) token {
    l->range.len += 1;
    for {
        let inescape bool = !lexer_ateof(l) && lexer_current(l) == '\\';
        if inescape { l->range.len += 1; }

        if lexer_ateof(l) { return lexer_emit(l, SK_ERROR); }
        if lexer_current(l) == '\n' { return lexer_emit(l, SK_ERROR); }
        if lexer_current(l) == delimiter && !inescape { break; }
        l->range.len += 1;
    }
    l->range.len += 1;
    return lexer_emit(l, kind);
}

fn lexer_rawstring(l *lexer) token {
    for {
        if lexer_ateof(l) || lexer_current(l) == '\n' { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_RAWSTRING);
}

fn lexer_comment(l *lexer) token {
    for {
        if lexer_ateof(l) || lexer_current(l) == '\n' { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_COMMENT);
}

fn lexer_atws(l *lexer) bool {
    return lexer_current(l) == ' ' || lexer_current(l) == '\n';
}

fn lexer_atdigit(l *lexer) bool {
    return lexer_current(l) >= '0' && lexer_current(l) <= '9';
}

fn lexer_atalpha(l *lexer) bool {
    return lexer_current(l) >= 'a' && lexer_current(l) <= 'z' ||
        lexer_current(l) >= 'A' && lexer_current(l) <= 'Z';
}

fn lexer_emit(l *lexer, kind char) token {
    let t token;
    t.kind = kind;
    t.range = l->range;

    l->range.start += l->range.len;
    l->range.len = 0;

    return t;
}

fn lexer_text(l *lexer) str {
    let s str;
    s.ptr = l->text.ptr + l->range.start;
    s.len = l->range.len;
    return s;
}

fn lexer_current(l *lexer) char {
    assert(!lexer_ateof(l));
    return *(l->text.ptr + l->range.start + l->range.len);
}

fn lexer_ateof(l *lexer) bool {
    return l->range.start + l->range.len >= l->text.len;
}

fn token_equal(t token, kind char, start int, len int) bool {
    return range_equal(t.range, start, len) && t.kind == kind;
}

fn token_print(t token) {
    printf("{ ");
    syntaxkind_print(t.kind);
    printf(", ");
    range_print(t.range);
    printf(" }\n");
}

fn test_lexer() {
    printf("    test empty\n"); test_lexer_empty();
    printf("    test ws\n"); test_lexer_ws();
    printf("    test number\n"); test_lexer_number();
    printf("    test numbers\n"); test_lexer_numbers();
    printf("    test idents\n"); test_lexer_idents();
    printf("    test strings\n"); test_lexer_strings();
    printf("    test no_multiline_strings\n"); test_lexer_no_multiline_strings();
    printf("    test unclosed_string\n"); test_lexer_unclosed_string();
    printf("    test no_escape_newline\n"); test_lexer_no_escape_newline();
    printf("    test char\n"); test_lexer_char();
    printf("    test symbols\n"); test_lexer_symbols();
    printf("    test keywords\n"); test_lexer_keywords();
    printf("    test comments\n"); test_lexer_comments();
    printf("    test rawstrings\n"); test_lexer_rawstrings();
}

fn test_lexer_empty() {
    let l lexer = lexer_new(str_empty());
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_ws() {
    let l lexer = lexer_new(str_new("  \n \n"));
    assert(token_equal(lexer_next(&l), SK_WS, 0, 5));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_number() {
    let l lexer = lexer_new(str_new("92"));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 0, 2));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_numbers() {
    let l lexer = lexer_new(str_new("1 2\n33 44"));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 0, 1));
    assert(token_equal(lexer_next(&l), SK_WS, 1, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 2, 1));
    assert(token_equal(lexer_next(&l), SK_WS, 3, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 4, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 6, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 7, 2));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_idents() {
    let l lexer = lexer_new(str_new("abc d EFG_H fnbAR01if6"));
    assert(token_equal(lexer_next(&l), SK_IDENT, 0, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 3, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 4, 1));
    assert(token_equal(lexer_next(&l), SK_WS, 5, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 6, 5));
    assert(token_equal(lexer_next(&l), SK_WS, 11, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 12, 10));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_strings() {
    let l lexer = lexer_new(str_new("\"\" \"?\" \"\\n\" \"\\\"\""));
    assert(token_equal(lexer_next(&l), SK_STRING, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_STRING, 3, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 6, 1));
    assert(token_equal(lexer_next(&l), SK_STRING, 7, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 11, 1));
    assert(token_equal(lexer_next(&l), SK_STRING, 12, 4));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_no_multiline_strings() {
    let l lexer = lexer_new(str_new("\"a\nb\""));
    assert(token_equal(lexer_next(&l), SK_ERROR, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 3, 1));
    assert(token_equal(lexer_next(&l), SK_ERROR, 4, 1));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_unclosed_string() {
    let l lexer = lexer_new(str_new("\"foo"));
    assert(token_equal(lexer_next(&l), SK_ERROR, 0, 4));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_no_escape_newline() {
    let l lexer = lexer_new(str_new("\"\\\n92"));
    assert(token_equal(lexer_next(&l), SK_ERROR, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 3, 2));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_char() {
    let l lexer = lexer_new(str_new("'a' '\\n' '\\\\' 'foo' '\\''"));
    assert(token_equal(lexer_next(&l), SK_CHAR, 0, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 3, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 4, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 8, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 9, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 13, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 14, 5));
    assert(token_equal(lexer_next(&l), SK_WS, 19, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 20, 4));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_symbols() {
    let l lexer = lexer_new(str_new(".:,;(){}+-*/=!&|<>"));
    assert(token_equal(lexer_next(&l), SK_DOT, 0, 1));
    assert(token_equal(lexer_next(&l), SK_COLON, 1, 1));
    assert(token_equal(lexer_next(&l), SK_COMMA, 2, 1));
    assert(token_equal(lexer_next(&l), SK_SEMI, 3, 1));
    assert(token_equal(lexer_next(&l), SK_LPAREN, 4, 1));
    assert(token_equal(lexer_next(&l), SK_RPAREN, 5, 1));
    assert(token_equal(lexer_next(&l), SK_LBRACE, 6, 1));
    assert(token_equal(lexer_next(&l), SK_RBRACE, 7, 1));
    assert(token_equal(lexer_next(&l), SK_PLUS, 8, 1));
    assert(token_equal(lexer_next(&l), SK_HYPEN, 9, 1));
    assert(token_equal(lexer_next(&l), SK_STAR, 10, 1));
    assert(token_equal(lexer_next(&l), SK_SLASH, 11, 1));
    assert(token_equal(lexer_next(&l), SK_EQUAL, 12, 1));
    assert(token_equal(lexer_next(&l), SK_BANG, 13, 1));
    assert(token_equal(lexer_next(&l), SK_PRETZEL, 14, 1));
    assert(token_equal(lexer_next(&l), SK_PIPE, 15, 1));
    assert(token_equal(lexer_next(&l), SK_LT, 16, 1));
    assert(token_equal(lexer_next(&l), SK_GT, 17, 1));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_keywords() {
    let l lexer = lexer_new(str_new("fn struct let if for break return"));
    assert(token_equal(lexer_next(&l), SK_FNKW, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_STRUCTKW, 3, 6));
    assert(token_equal(lexer_next(&l), SK_WS, 9, 1));
    assert(token_equal(lexer_next(&l), SK_LETKW, 10, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 13, 1));
    assert(token_equal(lexer_next(&l), SK_IFKW, 14, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 16, 1));
    assert(token_equal(lexer_next(&l), SK_FORKW, 17, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 20, 1));
    assert(token_equal(lexer_next(&l), SK_BREAKKW, 21, 5));
    assert(token_equal(lexer_next(&l), SK_WS, 26, 1));
    assert(token_equal(lexer_next(&l), SK_RETURNKW, 27, 6));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_comments() {
    let l lexer = lexer_new(str_new("# hello\n123#456"));
    assert(token_equal(lexer_next(&l), SK_COMMENT, 0, 7));
    assert(token_equal(lexer_next(&l), SK_WS, 7, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 8, 3));
    assert(token_equal(lexer_next(&l), SK_COMMENT, 11, 4));
}

fn test_lexer_rawstrings() {
    let l lexer = lexer_new(str_new("\\foo\n\\quux"));
    assert(token_equal(lexer_next(&l), SK_RAWSTRING, 0, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 4, 1));
    assert(token_equal(lexer_next(&l), SK_RAWSTRING, 5, 5));
}

struct syntaxchild {
    istoken bool,
    kind char,
    range range,
    next *syntaxchild,
    child *syntaxchild,
    parent *syntaxchild,
}

struct syntaxtree { root *syntaxchild }

struct syntaxbuilder {
    root *syntaxchild,
    current *syntaxchild,
    inputidx int,
}

fn syntaxbuilder_new() syntaxbuilder {
    let b syntaxbuilder;
    b.root = 0;
    b.current = 0;
    b.inputidx = 0;
    return b;
}

fn syntaxbuilder_startnode(b *syntaxbuilder, kind char) {
    let new syntaxchild;
    new.istoken = false;
    new.kind = kind;
    new.range.start = b->inputidx;
    new.range.len = 0;
    new.next = 0;
    new.child = 0;
    new.parent = b->current;

    let newallocated *syntaxchild = malloc(sizeof(syntaxchild));
    *newallocated = new;

    if b->current == 0 {
        b->current = newallocated;
        b->root = newallocated;
    } else {
        syntaxchild_addchild(b->current, newallocated);
        b->current = newallocated;
    }
}

fn syntaxbuilder_addtoken(b *syntaxbuilder, kind char, len int) {
    let child *syntaxchild = malloc(sizeof(syntaxchild));
    child->istoken = true;
    child->kind = kind;
    child->range.start = b->inputidx;
    child->range.len = len;
    child->next = 0;
    child->child = 0;
    child->parent = b->current;
    syntaxchild_addchild(b->current, child);
    b->inputidx += len;
}

fn syntaxbuilder_finishnode(b *syntaxbuilder) {
    b->current->range.len = b->inputidx - b->current->range.start;
    b->current = b->current->parent;
}

fn syntaxbuilder_finish(b syntaxbuilder) syntaxtree {
    let t syntaxtree;
    t.root = b.root;
    return t;
}

fn syntaxchild_addchild(c *syntaxchild, newchild *syntaxchild) {
    let placetoinsert **syntaxchild = &c->child;
    for {
        if *placetoinsert == 0 { break; }
        let c *syntaxchild = *placetoinsert;
        placetoinsert = &c->next;
    }
    *placetoinsert = newchild;
}

fn syntaxchild_findchild(c *syntaxchild, kind char) *syntaxchild {
    let child *syntaxchild = c->child;
    for {
        if child == 0 { break; }
        if child->kind == kind { return child; }
        child = child->next;
    }
    return 0;
}

fn syntaxtree_print(t syntaxtree, text *char) {
    let indentation int = 0;
    let current syntaxchild = *t.root;

    for {
        let i int = 0;
        for {
            if i == indentation { break; }
            printf("\x1B[90m│\x1B[0m ");
            i += 1;
        }

        syntaxkind_print(current.kind);
        printf(" ");
        range_print(current.range);

        if current.istoken {
            printf(" \x1B[35m\"");
            printf("\x1B[95m");
            let i int = 0;
            for {
                if i == current.range.len { break; }

                let c char = *(text + current.range.start + i);
                if c == '\n'
                    { printf("\\n"); }
                else
                    { printf("%c", c); }

                i += 1;
            }
            printf("\x1B[35m\"");
        }

        printf("\x1B[0m\n");

        if current.child == 0 {
            let c syntaxchild = current;
            for {
                if c.next != 0 { break; }
                if c.parent == 0 { return; }
                c = *c.parent;
                indentation -= 1;
            }
            current = *c.next;
        } else {
            current = *current.child;
            indentation += 1;
        }
    }
}

fn syntaxtree_format(t syntaxtree, text *char) str {
    let s str;
    s.ptr = malloc(1024);
    s.len = 0;

    let indentation int = 0;
    let current syntaxchild = *t.root;

    for {
        if indentation != 0 {
            *(s.ptr + s.len) = '\n';
            s.len += 1;
        }

        let i int = 0;
        for {
            if i == indentation { break; }

            *(s.ptr + s.len) = ' ';
            s.len += 1;
            *(s.ptr + s.len) = ' ';
            s.len += 1;

            i += 1;
        }

        let kind str = syntaxkind_format(current.kind);
        memcpy(s.ptr + s.len, kind.ptr, kind.len);
        s.len += kind.len;

        if current.istoken {
            *(s.ptr + s.len) = ' ';
            s.len += 1;

            *(s.ptr + s.len) = '"';
            s.len += 1;

            let i int = 0;
            for {
                if i == current.range.len { break; }
                let c char = *(text + current.range.start + i);
                if c == '\n' {
                    *(s.ptr + s.len) = '\\';
                    s.len += 1;
                    *(s.ptr + s.len) = 'n';
                    s.len += 1;
                } else {
                    *(s.ptr + s.len) = c;
                    s.len += 1;
                }
                i += 1;
            }

            *(s.ptr + s.len) = '"';
            s.len += 1;
        }

        if current.child == 0 {
            let c syntaxchild = current;
            for {
                if c.next != 0 { break; }
                if c.parent == 0 { return s; }
                c = *c.parent;
                indentation -= 1;
            }
            current = *c.next;
        } else {
            current = *current.child;
            indentation += 1;
        }
    }

    return s;
}

fn test_syntax() {
    printf("    test empty\n"); test_syntax_empty();
    printf("    test addtoken\n"); test_syntax_addtoken();
    printf("    test root\n"); test_syntax_root();
    printf("    test links\n"); test_syntax_links();
    printf("    test format\n"); test_syntax_format();
}

fn test_syntax_empty() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, 0);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finish(b);
}

fn test_syntax_addtoken() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_addtoken(&b, SK_FORKW, 3);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finish(b);
}

fn test_syntax_root() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_addtoken(&b, SK_WS, 1);
    syntaxbuilder_addtoken(&b, SK_WS, 1);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);
    let root syntaxchild = *t.root;
    assert(range_equal(root.range, 0, 2));
    assert(root.kind == SK_ROOT);
}

fn test_syntax_links() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);
    let root syntaxchild = *t.root;

    let node1 syntaxchild = *root.child;
    assert(node1.kind == SK_FUNCTION);
    assert(range_equal(node1.range, 0, 3));

    let node1child1 syntaxchild = *node1.child;
    assert(node1child1.kind == SK_FNKW);
    assert(range_equal(node1child1.range, 0, 2));

    let node1child2 syntaxchild = *node1child1.next;
    assert(node1child2.kind == SK_IDENT);
    assert(range_equal(node1child2.range, 2, 1));

    assert(node1child2.next == 0);

    let node2 syntaxchild = *node1.next;
    assert(node1.kind == SK_FUNCTION);
    assert(range_equal(node2.range, 3, 3));

    let node2child1 syntaxchild = *node2.child;
    assert(node1child1.kind == SK_FNKW);
    assert(range_equal(node2child1.range, 3, 2));

    let node2child2 syntaxchild = *node2child1.next;
    assert(node1child2.kind == SK_IDENT);
    assert(range_equal(node2child2.range, 5, 1));

    assert(node2child2.next == 0);

    assert(node2.next == 0);
}

fn test_syntax_format() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);

    assert(str_prettyequal(
        syntaxtree_format(t, "fnafnb"),
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    IDENT "a"
        \  FUNCTION
        \    FNKW "fn"
        \    IDENT "b"
    ));
}

struct parseresult { tree syntaxtree, errorsptr *syntaxerror, errorslen int }

struct event { kind char, syntaxkind char }
let EVENT_STARTNODE = 1;
let EVENT_ADDTOKEN = 2;
let EVENT_FINISHNODE = 3;

struct syntaxerror { range range, message str }

struct parser {
    tokens tokens,
    tokenidx int,
    eventsptr *event,
    eventslen int,
    eventscap int,
    errorsptr *syntaxerror,
    errorslen int,
    errorscap int,
}

fn parse(text str) parseresult {
    let p parser = parser_new(text);
    grammar_root(&p);

    let builder syntaxbuilder = syntaxbuilder_new();

    let eventidx int = 0;
    let tokenidx int = 0;
    for {
        if eventidx == p.eventslen { break; }

        let e event = *(p.eventsptr + eventidx);
        if e.kind == EVENT_STARTNODE {
            syntaxbuilder_startnode(&builder, e.syntaxkind);
        }
        if e.kind == EVENT_ADDTOKEN {
            let t token = *(p.tokens.ptr + tokenidx);
            syntaxbuilder_addtoken(&builder, t.kind, t.range.len);
            tokenidx += 1;
        }
        if e.kind == EVENT_FINISHNODE {
            syntaxbuilder_finishnode(&builder);
        }

        for {
            let t token = *(p.tokens.ptr + tokenidx);
            let istrivia bool = t.kind == SK_WS || t.kind == SK_COMMENT;
            if !istrivia { break; }
            syntaxbuilder_addtoken(&builder, t.kind, t.range.len);
            tokenidx += 1;
        }

        eventidx += 1;
    }

    let result parseresult;
    result.tree = syntaxbuilder_finish(builder);
    result.errorsptr = p.errorsptr;
    result.errorslen = p.errorslen;
    return result;
}

fn grammar_root(p *parser) {
    parser_startnode(p, SK_ROOT);
    for {
        if parser_at(p, SK_FNKW) { grammar_function(p); }
        else { break; }
    }
    parser_finishnode(p);
}

fn grammar_function(p *parser) {
    assert(parser_at(p, SK_FNKW));
    parser_startnode(p, SK_FUNCTION);
    parser_addtoken(p);

    parser_expect(p, SK_IDENT);

    parser_expect(p, SK_LPAREN);
    for {
        if parser_at(p, SK_RPAREN) { break; }
        parser_startnode(p, SK_PARAM);
        parser_expect(p, SK_IDENT);
        grammar_type(p);
        parser_finishnode(p);
        if parser_at(p, SK_RPAREN) { break; }
        parser_expect(p, SK_COMMA);
    }
    parser_addtoken(p);

    if !parser_at(p, SK_LBRACE) {
        grammar_type(p);
    }

    parser_expect(p, SK_LBRACE);
    parser_expect(p, SK_RBRACE);

    parser_finishnode(p);
}

fn grammar_type(p *parser) {
    assert(parser_at(p, SK_IDENT));
    parser_startnode(p, SK_TYPE);
    parser_addtoken(p);
    parser_finishnode(p);
}

fn parser_new(text str) parser {
    let p parser;

    p.tokens = lex(text);
    p.tokenidx = 0;

    let cap int = p.tokens.len * 2;
    p.eventsptr = malloc(cap * sizeof(event));
    p.eventslen = 0;
    p.eventscap = cap;

    p.errorsptr = malloc(8 * sizeof(syntaxerror));
    p.errorslen = 0;
    p.errorscap = 8;

    return p;
}

fn parser_expect(p *parser, kind char) {
    if !parser_at(p, kind) {
        let msg str;
        msg.ptr = malloc(1024);
        msg.len = 0;

        let s str = str_new("expected ");
        memcpy(msg.ptr + msg.len, s.ptr, s.len);
        msg.len += s.len;

        s = syntaxkind_format(kind);
        memcpy(msg.ptr + msg.len, s.ptr, s.len);
        msg.len += s.len;

        s = str_new(" but found ");
        memcpy(msg.ptr + msg.len, s.ptr, s.len);
        msg.len += s.len;

        s = syntaxkind_format(parser_peek(p));
        memcpy(msg.ptr + msg.len, s.ptr, s.len);
        msg.len += s.len;

        parser_error(p, (p->tokens.ptr + p->tokenidx)->range, msg);
        return;
    }
    parser_addtoken(p);
}

fn parser_at(p *parser, kind char) bool {
    parser_skipws(p);
    return parser_rawat(p, kind);
}

fn parser_peek(p *parser) char {
    parser_skipws(p);
    return parser_rawpeek(p);
}

fn parser_skipws(p *parser) {
    for {
        if !parser_rawat(p, SK_WS) { break; }
        p->tokenidx += 1;
    }
}

fn parser_rawat(p *parser, kind char) bool {
    if parser_ateof(p) { return false; }
    return parser_rawpeek(p) == kind;
}

fn parser_rawpeek(p *parser) char {
    assert(!parser_ateof(p));
    return (p->tokens.ptr + p->tokenidx)->kind;
}

fn parser_ateof(p *parser) bool {
    return p->tokenidx >= p->tokens.len;
}

fn parser_error(p *parser, range range, message str) {
    if p->errorslen == p->errorscap {
        p->errorscap *= 2;
        p->errorsptr = realloc(
            p->errorsptr,
            p->errorscap * sizeof(syntaxerror)
        );
    }

    let e syntaxerror;
    e.range = range;
    e.message = message;

    *(p->errorsptr + p->errorslen) = e;
    p->errorslen += 1;
}

fn parser_startnode(p *parser, kind char) {
    let e event;
    e.kind = EVENT_STARTNODE;
    e.syntaxkind = kind;
    parser_pushevent(p, e);
}

fn parser_addtoken(p *parser) {
    parser_skipws(p);
    let e event;
    e.kind = EVENT_ADDTOKEN;
    parser_pushevent(p, e);
    p->tokenidx += 1;
}

fn parser_finishnode(p *parser) {
    let e event;
    e.kind = EVENT_FINISHNODE;
    parser_pushevent(p, e);
}

fn parser_pushevent(p *parser, e event) {
    if p->eventslen == p->eventscap {
        p->eventscap *= 2;
        p->eventsptr = realloc(p->eventsptr, p->eventscap);
    }
    *(p->eventsptr + p->eventslen) = e;
    p->eventslen += 1;
}

fn test_parser() {
    printf("    test empty\n"); test_parser_empty();
    printf("    test emptyfunction\n"); test_parser_emptyfunction();
    printf("    test functionwithmissingname\n"); test_parser_functionwithmissingname();
    printf("    test functionwithreturntype\n"); test_parser_functionwithreturntype();
    printf("    test functionwithparameters\n"); test_parser_functionwithparameters();
    printf("    test functionwithparameterstrailingcomma\n"); test_parser_functionwithparameterstrailingcomma();
    printf("    test functionwithmissingparameterscomma\n"); test_parser_functionwithmissingparameterscomma();
    printf("    test multiplefunctions\n"); test_parser_multiplefunctions();
}

fn test_parser_empty() {
    parsertestharness(
        \
        ,
        \ROOT
    );
}

fn test_parser_emptyfunction() {
    parsertestharness(
        \fn a() {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "a"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    LBRACE "{"
        \    RBRACE "}"
    );
}

fn test_parser_functionwithmissingname() {
    parsertestharness(
        \fn () {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    LBRACE "{"
        \    RBRACE "}"
        \error at 3..4: expected IDENT but found LPAREN
    );
}

fn test_parser_functionwithreturntype() {
    parsertestharness(
        \fn a() int {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "a"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    TYPE
        \      IDENT "int"
        \      WS " "
        \    LBRACE "{"
        \    RBRACE "}"
    );
}

fn test_parser_functionwithparameters() {
    parsertestharness(
        \fn foo(x int, y int) {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "foo"
        \    LPAREN "("
        \    PARAM
        \      IDENT "x"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    COMMA ","
        \    WS " "
        \    PARAM
        \      IDENT "y"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    RPAREN ")"
        \    WS " "
        \    LBRACE "{"
        \    RBRACE "}"
    );
}

fn test_parser_functionwithparameterstrailingcomma() {
    parsertestharness(
        \fn g(i int,) {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "g"
        \    LPAREN "("
        \    PARAM
        \      IDENT "i"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    COMMA ","
        \    RPAREN ")"
        \    WS " "
        \    LBRACE "{"
        \    RBRACE "}"
    );
}

fn test_parser_functionwithmissingparameterscomma() {
    parsertestharness(
        \fn a(a int b int) {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "a"
        \    LPAREN "("
        \    PARAM
        \      IDENT "a"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \        WS " "
        \    PARAM
        \      IDENT "b"
        \      WS " "
        \      TYPE
        \        IDENT "int"
        \    RPAREN ")"
        \    WS " "
        \    LBRACE "{"
        \    RBRACE "}"
        \error at 11..12: expected COMMA but found IDENT
    );
}

fn test_parser_multiplefunctions() {
    parsertestharness(
        \fn a() {}
        \fn b() {}
        ,
        \ROOT
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "a"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    LBRACE "{"
        \    RBRACE "}"
        \    WS "\n"
        \  FUNCTION
        \    FNKW "fn"
        \    WS " "
        \    IDENT "b"
        \    LPAREN "("
        \    RPAREN ")"
        \    WS " "
        \    LBRACE "{"
        \    RBRACE "}"
    );
}

fn parsertestharness(text *char, expected *char) {
    let result parseresult = parse(str_new(text));
    let actual str = syntaxtree_format(result.tree, text);

    let i int = 0;
    for {
        if i == result.errorslen { break; }
        let error syntaxerror = *(result.errorsptr + i);

        let len int = sprintf(
            actual.ptr + actual.len,
            "\nerror at %d..%d: ",
            error.range.start,
            error.range.start + error.range.len,
        );
        actual.len += len;

        memcpy(actual.ptr + actual.len, error.message.ptr, error.message.len);
        actual.len += error.message.len;

        i += 1;
    }

    if !str_prettyequal(actual, expected) { exit(1); }
}

struct fileindex { functionsptr *function, functionslen int, functionscap int }
struct type { name range }
struct param { name range, type type }
struct function {
    name range,
    paramsptr *param,
    paramslen int,
    paramscap int,
    returntype *type,
}

fn fileindex_new(tree syntaxtree) fileindex {
    let i fileindex;
    i.functionsptr = malloc(8 * sizeof(function));
    i.functionslen = 0;
    i.functionscap = 8;

    let child *syntaxchild = tree.root->child;
    for {
        if child == 0 { break; }
        if child->kind == SK_FUNCTION {
            let f function;
            f.name = syntaxchild_findchild(child, SK_IDENT)->range;
            f.paramsptr = malloc(4 * sizeof(param));
            f.paramslen = 0;
            f.paramscap = 4;

            let c *syntaxchild = child->child;
            for {
                if c == 0 { break; }
                if c->kind == SK_PARAM {
                    if f.paramscap == f.paramslen {
                        f.paramscap *= 2;
                        f.paramsptr = realloc(f.paramsptr, f.paramscap);
                    }
                    (f.paramsptr + f.paramslen)->name =
                        syntaxchild_findchild(c, SK_IDENT)->range;
                    (f.paramsptr + f.paramslen)->type =
                        lowertype(syntaxchild_findchild(c, SK_TYPE));
                    f.paramslen += 1;
                }
                c = c->next;
            }

            let returntype *syntaxchild = syntaxchild_findchild(child, SK_TYPE);
            if returntype == 0 {
                f.returntype = 0;
            } else {
                f.returntype = malloc(sizeof(type));
                *f.returntype = lowertype(returntype);
            }

            if i.functionslen == i.functionscap {
                i.functionscap *= 2;
                i.functionsptr = realloc(i.functionsptr, i.functionscap);
            }
            *(i.functionsptr + i.functionslen) = f;
            i.functionslen += 1;
        }
        child = child->next;
    }

    return i;
}

fn lowertype(c *syntaxchild) type {
    let t type;
    let name *syntaxchild = syntaxchild_findchild(c, SK_IDENT);
    t.name = name->range;
    return t;
}

fn fileindex_format(index fileindex, text *char) str {
    let s str;
    s.ptr = malloc(1024);
    s.len = 0;

    let i int = 0;
    for {
        if i == index.functionslen { break; }

        if i != 0 {
            *(s.ptr + s.len) = '\n';
            s.len += 1;
        }

        let f function = *(index.functionsptr + i);

        memcpy(s.ptr + s.len, "fn ", 3);
        s.len += 3;

        memcpy(s.ptr + s.len, text + f.name.start, f.name.len);
        s.len += f.name.len;

        memcpy(s.ptr + s.len, "(", 1);
        s.len += 1;

        let paramidx int = 0;
        for {
            if paramidx == f.paramslen { break; }

            if paramidx != 0 {
                memcpy(s.ptr + s.len, ", ", 2);
                s.len += 2;
            }

            let p param = *(f.paramsptr + paramidx);

            memcpy(s.ptr + s.len, text + p.name.start, p.name.len);
            s.len += p.name.len;

            memcpy(s.ptr + s.len, " ", 1);
            s.len += 1;

            memcpy(s.ptr + s.len, text + p.type.name.start, p.type.name.len);
            s.len += p.type.name.len;

            paramidx += 1;
        }

        memcpy(s.ptr + s.len, ") ", 2);
        s.len += 2;

        if f.returntype != 0 {
            memcpy(
                s.ptr + s.len,
                text + f.returntype->name.start,
                f.returntype->name.len
            );
            s.len += f.returntype->name.len;
            memcpy(s.ptr + s.len, " ", 1);
            s.len += 1;
        }

        memcpy(s.ptr + s.len, "{}", 2);
        s.len += 2;

        i += 1;
    }

    return s;
}

fn test_indexing() {
    printf("    test empty\n"); test_indexing_empty();
    printf("    test simplefunction\n"); test_indexing_simplefunction();
    printf("    test functions\n"); test_indexing_functions();
    printf("    test functionwithreturntype\n"); test_indexing_functionwithreturntype();
    printf("    test functionwithparameters\n"); test_indexing_functionwithparameters();
}

fn test_indexing_empty() {
    indexingtestharness("", "");
}

fn test_indexing_simplefunction() {
    indexingtestharness(
        \fn a() {}
        ,
        \fn a() {}
    );
}

fn test_indexing_functions() {
    indexingtestharness(
        \fn x() {}
        \fn y() {}
        ,
        \fn x() {}
        \fn y() {}
    );
}

fn test_indexing_functionwithreturntype() {
    indexingtestharness(
        \fn f() int {}
        ,
        \fn f() int {}
    );
}

fn test_indexing_functionwithparameters() {
    indexingtestharness(
        \fn add(x int, y int) int {}
        ,
        \fn add(x int, y int) int {}
    );
}

fn indexingtestharness(text *char, expected *char) {
    let r parseresult = parse(str_new(text));
    let i fileindex = fileindex_new(r.tree);
    let actual str = fileindex_format(i, text);

    if !str_prettyequal(actual, expected) { exit(1); }
}
